/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/setup/SetupGuideModal.ts
var SetupGuideModal_exports = {};
__export(SetupGuideModal_exports, {
  SetupGuideModal: () => SetupGuideModal
});
var import_obsidian, SetupGuideModal;
var init_SetupGuideModal = __esm({
  "src/setup/SetupGuideModal.ts"() {
    import_obsidian = require("obsidian");
    SetupGuideModal = class extends import_obsidian.Modal {
      constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("hwp-setup-guide");
        contentEl.createEl("h1", { text: "\u{1F680} HWP Writer \uC124\uCE58 \uAC00\uC774\uB4DC" });
        contentEl.createEl("p", {
          text: "\uC544\uB798 3\uB2E8\uACC4\uB9CC \uB530\uB77C\uD558\uBA74 \uC124\uCE58 \uB05D! \uD55C \uBC88\uB9CC \uD558\uBA74 \uB2E4\uC2DC\uB294 \uC124\uCE58\uD560 \uC77C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.",
          cls: "hwp-setup-subtitle"
        });
        const statusEl = contentEl.createDiv("hwp-setup-status");
        this.renderStatus(statusEl);
        const step1 = contentEl.createDiv("hwp-setup-step");
        step1.createEl("h2", { text: "\u{1F4E6} Step 1. Python \uC124\uCE58" });
        step1.createEl("p", { text: "Python\uC740 HWP Writer\uAC00 \uD55C\uAE00 \uBB38\uC11C(.hwpx)\uB97C \uB9CC\uB4E4 \uB54C \uC0AC\uC6A9\uD558\uB294 \uD504\uB85C\uADF8\uB7A8\uC785\uB2C8\uB2E4." });
        const howto1 = step1.createDiv("hwp-setup-howto");
        howto1.createEl("h3", { text: "\uBC29\uBC95 A: \uACF5\uC2DD \uC0AC\uC774\uD2B8\uC5D0\uC11C \uC124\uCE58 (\uAD8C\uC7A5)" });
        const steps1a = howto1.createEl("ol");
        steps1a.createEl("li").innerHTML = '<a href="https://www.python.org/downloads/">python.org/downloads</a> \uC5D0 \uC811\uC18D\uD569\uB2C8\uB2E4';
        steps1a.createEl("li").innerHTML = '\uB178\uB780\uC0C9 <strong>"Download Python 3.xx.x"</strong> \uBC84\uD2BC\uC744 \uD074\uB9AD\uD569\uB2C8\uB2E4';
        steps1a.createEl("li").innerHTML = "\uB2E4\uC6B4\uB85C\uB4DC\uB41C \uD30C\uC77C\uC744 \uC2E4\uD589\uD569\uB2C8\uB2E4";
        steps1a.createEl("li").innerHTML = '\u26A0\uFE0F <strong>\uC124\uCE58 \uD654\uBA74 \uB9E8 \uC544\uB798 "Add python.exe to PATH"\uC5D0 \uBC18\uB4DC\uC2DC \uCCB4\uD06C!</strong>';
        steps1a.createEl("li").innerHTML = '"Install Now"\uB97C \uD074\uB9AD\uD558\uACE0 \uC124\uCE58 \uC644\uB8CC\uB97C \uAE30\uB2E4\uB9BD\uB2C8\uB2E4';
        const warn1 = step1.createDiv("hwp-setup-warning");
        warn1.innerHTML = '\u26A0\uFE0F <strong>"Add python.exe to PATH"</strong>\uC5D0 \uCCB4\uD06C\uD558\uC9C0 \uC54A\uC73C\uBA74 HWP Writer\uAC00 Python\uC744 \uCC3E\uC9C0 \uBABB\uD569\uB2C8\uB2E4. \uBC18\uB4DC\uC2DC \uCCB4\uD06C\uD574\uC8FC\uC138\uC694!';
        howto1.createEl("h3", { text: "\uBC29\uBC95 B: Microsoft Store\uC5D0\uC11C \uC124\uCE58" });
        const steps1b = howto1.createEl("ol");
        steps1b.createEl("li").innerHTML = 'Windows \uC2DC\uC791 \uBA54\uB274\uC5D0\uC11C <strong>"Microsoft Store"</strong>\uC744 \uAC80\uC0C9\uD569\uB2C8\uB2E4';
        steps1b.createEl("li").innerHTML = '"Python 3.12"\uB97C \uAC80\uC0C9\uD569\uB2C8\uB2E4';
        steps1b.createEl("li").innerHTML = '"\uC124\uCE58" \uBC84\uD2BC\uC744 \uD074\uB9AD\uD569\uB2C8\uB2E4 \u2014 \uB05D!';
        const step2 = contentEl.createDiv("hwp-setup-step");
        step2.createEl("h2", { text: "\u{1F4C4} Step 2. Pandoc \uC124\uCE58" });
        step2.createEl("p", { text: "Pandoc\uC740 \uB9C8\uD06C\uB2E4\uC6B4\uC744 \uC5EC\uB7EC \uD615\uC2DD\uC73C\uB85C \uBCC0\uD658\uD558\uB294 \uB3C4\uAD6C\uC785\uB2C8\uB2E4." });
        const howto2 = step2.createDiv("hwp-setup-howto");
        const steps2 = howto2.createEl("ol");
        steps2.createEl("li").innerHTML = '<a href="https://pandoc.org/installing.html">pandoc.org/installing</a> \uC5D0 \uC811\uC18D\uD569\uB2C8\uB2E4';
        steps2.createEl("li").innerHTML = "Windows \uD56D\uBAA9\uC5D0\uC11C <strong>.msi \uC778\uC2A4\uD1A8\uB7EC</strong>\uB97C \uB2E4\uC6B4\uB85C\uB4DC\uD569\uB2C8\uB2E4";
        steps2.createEl("li").innerHTML = '\uB2E4\uC6B4\uB85C\uB4DC\uB41C \uD30C\uC77C\uC744 \uC2E4\uD589 \u2192 "Next" \u2192 "Next" \u2192 "Install" \u2192 "Finish"';
        steps2.createEl("li").innerHTML = "\uC124\uCE58 \uC644\uB8CC! (\uB530\uB85C \uC124\uC815\uD560 \uAC83\uC740 \uC5C6\uC2B5\uB2C8\uB2E4)";
        const step3 = contentEl.createDiv("hwp-setup-step");
        step3.createEl("h2", { text: "\u2699\uFE0F Step 3. \uD55C\uAE00 \uBCC0\uD658 \uB3C4\uAD6C \uC124\uCE58 (\uB9C8\uC9C0\uB9C9!)" });
        step3.createEl("p", { text: "\uBA85\uB839 \uD504\uB86C\uD504\uD2B8(CMD)\uB97C \uC5F4\uC5B4\uC11C \uD55C \uC904\uB9CC \uC785\uB825\uD558\uBA74 \uB429\uB2C8\uB2E4." });
        const howto3 = step3.createDiv("hwp-setup-howto");
        const steps3 = howto3.createEl("ol");
        steps3.createEl("li").innerHTML = 'Windows \uD0A4\uB97C \uB204\uB974\uACE0 <strong>"cmd"</strong>\uB97C \uC785\uB825 \u2192 "\uBA85\uB839 \uD504\uB86C\uD504\uD2B8" \uD074\uB9AD';
        steps3.createEl("li").innerHTML = "\uC544\uB798 \uBA85\uB839\uC5B4\uB97C \uBCF5\uC0AC\uD574\uC11C \uBD99\uC5EC\uB123\uAE30 \u2192 Enter:";
        const cmdBox = howto3.createDiv("hwp-setup-cmd");
        const installCmd = "python -m pip install pypandoc pypandoc-hwpx pillow";
        cmdBox.createEl("code", {
          text: installCmd
        });
        const copyBtn = howto3.createEl("button", {
          text: "\u{1F4CB} \uBA85\uB839\uC5B4 \uBCF5\uC0AC",
          cls: "hwp-setup-copy-btn"
        });
        copyBtn.addEventListener("click", () => {
          navigator.clipboard.writeText(installCmd);
          copyBtn.textContent = "\u2705 \uBCF5\uC0AC \uC644\uB8CC!";
          setTimeout(() => copyBtn.textContent = "\u{1F4CB} \uBA85\uB839\uC5B4 \uBCF5\uC0AC", 2e3);
        });
        steps3.createEl("li").innerHTML = '"Successfully installed"\uAC00 \uB098\uC624\uBA74 <strong>\uC124\uCE58 \uC644\uC804 \uB05D!</strong> \u{1F389}';
        const done = contentEl.createDiv("hwp-setup-done");
        done.createEl("h2", { text: "\u{1F389} \uC124\uCE58 \uC644\uB8CC!" });
        done.createEl("p", {
          text: "\uC774\uC81C \uC635\uC2DC\uB514\uC5B8\uC5D0\uC11C \uB9C8\uD06C\uB2E4\uC6B4\uC744 \uC4F0\uACE0, \uC6D0\uD074\uB9AD\uC73C\uB85C \uD55C\uAE00 \uBB38\uC11C(.hwpx)\uB97C \uB9CC\uB4E4 \uC218 \uC788\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC\uB294 \uC774 \uACFC\uC815\uC744 \uBC18\uBCF5\uD560 \uD544\uC694\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4!"
        });
        const footer = contentEl.createDiv("hwp-setup-footer");
        new import_obsidian.Setting(footer).addButton(
          (btn) => btn.setButtonText("\u2705 \uC124\uCE58 \uD655\uC778\uD558\uAE30").setCta().onClick(async () => {
            await this.verifyInstallation(statusEl);
          })
        ).addButton(
          (btn) => btn.setButtonText("\uB2EB\uAE30").onClick(() => this.close())
        );
      }
      async renderStatus(el) {
        el.empty();
        el.createEl("h3", { text: "\uD604\uC7AC \uC124\uCE58 \uC0C1\uD0DC" });
        const table = el.createEl("table", { cls: "hwp-setup-status-table" });
        const tbody = table.createEl("tbody");
        const items = [
          { name: "Python", status: "\uD655\uC778 \uC911..." },
          { name: "Pandoc", status: "\uD655\uC778 \uC911..." },
          { name: "pypandoc-hwpx", status: "\uD655\uC778 \uC911..." }
        ];
        for (const item of items) {
          const row = tbody.createEl("tr");
          row.createEl("td", { text: item.name });
          row.createEl("td", { text: item.status, cls: "hwp-status-cell" });
        }
        setTimeout(() => this.verifyInstallation(el), 500);
      }
      async verifyInstallation(statusEl) {
        statusEl.empty();
        statusEl.createEl("h3", { text: "\uD604\uC7AC \uC124\uCE58 \uC0C1\uD0DC" });
        const table = statusEl.createEl("table", { cls: "hwp-setup-status-table" });
        const tbody = table.createEl("tbody");
        const pythonOk = await this.checkCommand(
          this.plugin.settings.pythonPath,
          ["--version"]
        );
        this.addStatusRow(tbody, "Python", pythonOk);
        const pandocOk = await this.checkCommand(
          this.plugin.settings.pandocPath,
          ["--version"]
        );
        this.addStatusRow(tbody, "Pandoc", pandocOk);
        const pipOk = await this.checkCommand(this.plugin.settings.pythonPath, [
          "-c",
          "from pypandoc_hwpx.PandocToHwpx import PandocToHwpx; from pypandoc_hwpx.PandocToHtml import PandocToHtml; print('OK')"
        ]);
        this.addStatusRow(tbody, "pypandoc-hwpx", pipOk);
        if (pythonOk && pandocOk && pipOk) {
          const allGood = statusEl.createDiv("hwp-status-all-good");
          allGood.innerHTML = "\u2705 <strong>\uBAA8\uB4E0 \uC124\uCE58\uAC00 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!</strong> HWPX \uB0B4\uBCF4\uB0B4\uAE30\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.";
        }
      }
      addStatusRow(tbody, name, ok) {
        const row = tbody.createEl("tr");
        row.createEl("td", { text: name });
        const cell = row.createEl("td", {
          text: ok ? "\u2705 \uC124\uCE58\uB428" : "\u274C \uBBF8\uC124\uCE58",
          cls: ok ? "hwp-status-ok" : "hwp-status-fail"
        });
      }
      async checkCommand(cmd, args) {
        try {
          const { execFile: execFile2 } = require("child_process");
          return new Promise((resolve) => {
            execFile2(cmd, args, { timeout: 1e4 }, (error, stdout) => {
              resolve(!error);
            });
          });
        } catch (e) {
          return false;
        }
      }
      onClose() {
        this.contentEl.empty();
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HwpWriterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_FONT_DIR = process.platform === "win32" ? "C:\\Windows\\Fonts" : process.platform === "darwin" ? "/System/Library/Fonts" : "/usr/share/fonts";
var DEFAULT_SETTINGS = {
  isFirstRun: true,
  pythonPath: "python",
  pandocPath: "pandoc",
  defaultTemplatePath: "",
  // 빈 문자열 = 플러그인 내장 blank.hwpx
  cachedTemplateStyles: {},
  cachedTemplatePageLayout: null,
  toolbarPosition: "top",
  showToolbarOnStartup: true,
  previewPosition: "right",
  enableLivePreview: true,
  fontDirectoryPath: DEFAULT_FONT_DIR
};
var HwpWriterSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "HWP Writer \uC124\uC815" });
    containerEl.createEl("h2", { text: "\u{1F40D} Python / Pandoc \uC124\uC815" });
    containerEl.createEl("p", {
      text: "HWPX \uB0B4\uBCF4\uB0B4\uAE30\uB97C \uC0AC\uC6A9\uD558\uB824\uBA74 Python\uACFC Pandoc\uC774 \uC124\uCE58\uB418\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Python \uACBD\uB85C").setDesc("Python \uC2E4\uD589 \uD30C\uC77C \uACBD\uB85C (\uC608: python, python3, C:\\Python312\\python.exe)").addText(
      (text) => text.setPlaceholder("python").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
        this.plugin.settings.pythonPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Pandoc \uACBD\uB85C").setDesc("Pandoc \uC2E4\uD589 \uD30C\uC77C \uACBD\uB85C (\uC608: pandoc, C:\\Program Files\\Pandoc\\pandoc.exe)").addText(
      (text) => text.setPlaceholder("pandoc").setValue(this.plugin.settings.pandocPath).onChange(async (value) => {
        this.plugin.settings.pandocPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\uC124\uCE58 \uAC00\uC774\uB4DC \uBCF4\uAE30").setDesc("Python\uACFC Pandoc \uC124\uCE58 \uBC29\uBC95\uC744 \uB2E8\uACC4\uBCC4\uB85C \uC548\uB0B4\uD569\uB2C8\uB2E4").addButton(
      (btn) => btn.setButtonText("\uC124\uCE58 \uAC00\uC774\uB4DC \uC5F4\uAE30").onClick(() => {
        const { SetupGuideModal: SetupGuideModal2 } = (init_SetupGuideModal(), __toCommonJS(SetupGuideModal_exports));
        new SetupGuideModal2(this.app, this.plugin).open();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4C4} HWPX \uD15C\uD50C\uB9BF" });
    containerEl.createEl("p", {
      text: "HWPX \uBCC0\uD658 \uBC0F \uBBF8\uB9AC\uBCF4\uAE30\uC5D0 \uC0AC\uC6A9\uD560 \uD15C\uD50C\uB9BF\uC785\uB2C8\uB2E4. \uBE44\uC5B4\uC788\uC73C\uBA74 \uD50C\uB7EC\uADF8\uC778 \uB0B4\uC7A5 \uAE30\uBCF8 \uD15C\uD50C\uB9BF(blank.hwpx)\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("\uD15C\uD50C\uB9BF \uC120\uD0DD").setDesc("\u{1F4C1} \uD234\uBC14\uC758 \uD15C\uD50C\uB9BF \uBC84\uD2BC\uC73C\uB85C \uC120\uD0DD\uD558\uAC70\uB098 \uC5EC\uAE30\uC5D0 \uC9C1\uC811 \uC785\uB825").addText(
      (text) => text.setPlaceholder("(\uAE30\uBCF8 \uB0B4\uC7A5 \uD15C\uD50C\uB9BF)").setValue(this.plugin.settings.defaultTemplatePath).onChange(async (value) => {
        this.plugin.settings.defaultTemplatePath = value;
        await this.plugin.saveSettings();
      })
    );
    const cached = this.plugin.settings.cachedTemplateStyles;
    if (cached && Object.keys(cached).length > 0) {
      const infoDiv = containerEl.createDiv("setting-item-description");
      infoDiv.style.marginTop = "8px";
      const heading1 = cached["Heading 1"];
      if (heading1) {
        infoDiv.setText(
          `\uD604\uC7AC \uD15C\uD50C\uB9BF \u2014 \uC81C\uBAA91: ${heading1.fontFamily} ${heading1.fontSize_pt}pt, \uBCF8\uBB38: ${((_a = cached["Normal"]) == null ? void 0 : _a.fontFamily) || "?"} ${((_b = cached["Normal"]) == null ? void 0 : _b.fontSize_pt) || "?"}pt`
        );
      }
    }
    containerEl.createEl("h2", { text: "\u{1F5A5}\uFE0F UI \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uC2DC\uC791 \uC2DC \uD234\uBC14 \uD45C\uC2DC").setDesc("Obsidian \uC2DC\uC791 \uC2DC HWP \uD234\uBC14\uB97C \uC790\uB3D9\uC73C\uB85C \uD45C\uC2DC\uD569\uB2C8\uB2E4").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showToolbarOnStartup).onChange(async (value) => {
        this.plugin.settings.showToolbarOnStartup = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\uC2E4\uC2DC\uAC04 \uBBF8\uB9AC\uBCF4\uAE30").setDesc("\uB9C8\uD06C\uB2E4\uC6B4 \uC218\uC815 \uC2DC \uC2E4\uC2DC\uAC04\uC73C\uB85C HWP \uC2A4\uD0C0\uC77C \uBBF8\uB9AC\uBCF4\uAE30\uB97C \uC5C5\uB370\uC774\uD2B8\uD569\uB2C8\uB2E4").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableLivePreview).onChange(async (value) => {
        this.plugin.settings.enableLivePreview = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F524} \uD3F0\uD2B8 \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uC2DC\uC2A4\uD15C \uD3F0\uD2B8 \uB514\uB809\uD1A0\uB9AC").setDesc(`\uBBF8\uB9AC\uBCF4\uAE30\uC5D0\uC11C \uC0AC\uC6A9\uD560 \uC2DC\uC2A4\uD15C \uD3F0\uD2B8 \uACBD\uB85C. \uAE30\uBCF8\uAC12: ${DEFAULT_FONT_DIR}`).addText(
      (text) => text.setPlaceholder(DEFAULT_FONT_DIR).setValue(this.plugin.settings.fontDirectoryPath).onChange(async (value) => {
        this.plugin.settings.fontDirectoryPath = value;
        await this.plugin.saveSettings();
      })
    ).addButton(
      (btn) => btn.setButtonText("\uD3F0\uD2B8 \uB2E4\uC2DC \uB85C\uB4DC").onClick(async () => {
        await this.plugin.refreshTemplateStyles();
        const { Notice: Notice6 } = require("obsidian");
        new Notice6(`\uD3F0\uD2B8 \uC7AC\uB85C\uB4DC \uBC0F \uBBF8\uB9AC\uBCF4\uAE30 \uAC31\uC2E0 \uC644\uB8CC`);
      })
    );
  }
};

// src/toolbar/ToolbarView.ts
var import_obsidian3 = require("obsidian");
var INLINE_MARKDOWN_TOKENS = [
  { name: "\uAD75\uAC8C", open: "**", close: "**" },
  { name: "\uAD75\uAC8C", open: "__", close: "__" },
  { name: "\uCDE8\uC18C\uC120", open: "~~", close: "~~" },
  { name: "\uD615\uAD11\uD39C", open: "==", close: "==" },
  { name: "\uC778\uB77C\uC778 \uCF54\uB4DC", open: "`", close: "`" },
  { name: "\uC778\uB77C\uC778 \uC218\uC2DD", open: "$", close: "$" },
  { name: "\uAE30\uC6B8\uC784", open: "*", close: "*" },
  { name: "\uAE30\uC6B8\uC784", open: "_", close: "_" }
];
var ToolbarManager = class {
  constructor(plugin) {
    this.currentToolbar = null;
    this.visible = true;
    this.openMenu = null;
    this.formatBrushActive = false;
    this.formatBrushLabel = "";
    this.formatBrushApply = null;
    this.formatBrushButton = null;
    this.lastBrushPattern = null;
    this.formatBrushArmedAt = 0;
    this.lastBrushAppliedSelection = "";
    this.plugin = plugin;
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", (leaf) => {
        if (this.visible)
          this.injectToolbar(leaf);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("layout-change", () => {
        if (!this.visible)
          return;
        const leaf = this.plugin.app.workspace.activeLeaf;
        if (leaf)
          this.injectToolbar(leaf);
      })
    );
    this.plugin.registerDomEvent(document, "mousedown", (evt) => {
      if (!this.openMenu)
        return;
      const target = evt.target;
      if (!target || !this.openMenu.contains(target)) {
        this.closeMenu();
      }
    });
    this.plugin.registerDomEvent(document, "keydown", (evt) => {
      if (evt.key !== "Escape")
        return;
      this.closeMenu();
      if (this.formatBrushActive)
        this.clearFormatBrush(false);
    });
    this.plugin.registerDomEvent(document, "mouseup", () => {
      this.applyFormatBrushFromSelection();
    });
    this.plugin.registerDomEvent(document, "keyup", () => {
      this.applyFormatBrushFromSelection();
    });
  }
  toggle() {
    this.visible = !this.visible;
    if (this.visible) {
      const leaf = this.plugin.app.workspace.activeLeaf;
      if (leaf)
        this.injectToolbar(leaf);
    } else {
      this.removeToolbar();
    }
  }
  injectToolbar(leaf) {
    this.removeToolbar();
    if (!leaf)
      return;
    const view = leaf.view;
    if (!(view instanceof import_obsidian3.MarkdownView))
      return;
    const viewContent = view.containerEl;
    if (!viewContent)
      return;
    const toolbar = createDiv("hwp-toolbar-container");
    this.currentToolbar = toolbar;
    const mainBar = toolbar.createDiv("hwp-toolbar-main");
    this.renderMainToolbar(mainBar);
    const formatBar = toolbar.createDiv("hwp-toolbar-format");
    this.renderFormatToolbar(formatBar);
    const firstChild = viewContent.firstChild;
    if (firstChild) {
      viewContent.insertBefore(toolbar, firstChild);
    } else {
      viewContent.appendChild(toolbar);
    }
  }
  removeToolbar() {
    this.closeMenu();
    this.clearFormatBrush(false);
    if (this.currentToolbar) {
      this.currentToolbar.remove();
      this.currentToolbar = null;
    }
    this.formatBrushButton = null;
    document.querySelectorAll(".hwp-toolbar-container").forEach((el) => el.remove());
  }
  destroy() {
    this.removeToolbar();
  }
  // -- 1단 메인 툴바 --
  renderMainToolbar(el) {
    const fileGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(fileGroup, "file-plus", "\uC0C8 \uBB38\uC11C", () => {
      this.execCmd("file-explorer:new-file");
    });
    this.addButton(fileGroup, "folder-open", "\uBD88\uB7EC\uC624\uAE30", () => {
      this.execCmd("switcher:open");
    });
    this.addButton(fileGroup, "save", "\uC800\uC7A5", () => {
      this.runEditorCommand(["editor:save-file"]);
    });
    el.createDiv("hwp-toolbar-divider");
    const exportGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(
      exportGroup,
      "file-output",
      "HWPX \uB0B4\uBCF4\uB0B4\uAE30",
      () => this.execCmd("obsidian-hwp-writer:export-hwpx"),
      "HWPX"
    );
    this.addButton(
      exportGroup,
      "file-text",
      "PDF \uB0B4\uBCF4\uB0B4\uAE30",
      () => this.execCmd("obsidian-hwp-writer:export-pdf"),
      "PDF"
    );
    this.addButton(
      exportGroup,
      "code",
      "HTML \uB0B4\uBCF4\uB0B4\uAE30",
      () => this.execCmd("obsidian-hwp-writer:export-html"),
      "HTML"
    );
    el.createDiv("hwp-toolbar-divider");
    const editGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(editGroup, "undo", "\uB418\uB3CC\uB9AC\uAE30 (Ctrl+Z)", () => {
      this.handleUndo();
    });
    this.addButton(editGroup, "redo", "\uB2E4\uC2DC \uC2E4\uD589 (Ctrl+Y)", () => {
      this.handleRedo();
    });
    el.createDiv("hwp-toolbar-divider");
    const insertGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(insertGroup, "table", "\uD45C \uC0BD\uC785", () => {
      this.execCmd("obsidian-hwp-writer:insert-table");
    });
    this.addButton(insertGroup, "minus", "\uC218\uD3C9\uC120 \uC0BD\uC785", () => {
      this.execCmd("obsidian-hwp-writer:insert-hr");
    });
    this.addButton(insertGroup, "code", "\uCF54\uB4DC \uBE14\uB85D \uC0BD\uC785", () => {
      this.execCmd("obsidian-hwp-writer:insert-codeblock");
    });
    this.addButton(insertGroup, "paperclip", "\uCCA8\uBD80\uD30C\uC77C \uC0BD\uC785", () => {
      this.runEditorCommand(["editor:attach-file"], "obsidian-hwp-writer:insert-embed");
    });
    el.createDiv("hwp-toolbar-divider");
    const viewGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(
      viewGroup,
      "columns",
      "\uBD84\uD560 \uBBF8\uB9AC\uBCF4\uAE30",
      () => this.execCmd("obsidian-hwp-writer:toggle-preview"),
      "\uBD84\uD560"
    );
    el.createDiv("hwp-toolbar-divider");
    const settingGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(
      settingGroup,
      "file-check",
      "HWPX \uD15C\uD50C\uB9BF \uC120\uD0DD",
      () => this.execCmd("obsidian-hwp-writer:select-template"),
      "\u{1F4C4} \uD15C\uD50C\uB9BF"
    );
    el.createDiv("hwp-toolbar-divider");
    const utilGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(utilGroup, "settings", "\uC124\uC815", () => {
      var _a, _b;
      (_a = this.plugin.app.setting) == null ? void 0 : _a.open();
      (_b = this.plugin.app.setting) == null ? void 0 : _b.openTabById("obsidian-hwp-writer");
    });
    this.addButton(utilGroup, "help-circle", "\uC124\uCE58 \uAC00\uC774\uB4DC", () => {
      this.execCmd("obsidian-hwp-writer:show-setup-guide");
    });
  }
  // -- 2단 서식 툴바 --
  renderFormatToolbar(el) {
    const styleGroup = el.createDiv("hwp-toolbar-group");
    const styleSelect = styleGroup.createEl("select", { cls: "hwp-style-dropdown" });
    const styles = [
      { value: "p", label: "\uBCF8\uBB38" },
      { value: "h1", label: "\uAC1C\uC694 1 (\uB300\uC81C\uBAA9)" },
      { value: "h2", label: "\uAC1C\uC694 2 (\uC911\uC81C\uBAA9)" },
      { value: "h3", label: "\uAC1C\uC694 3" },
      { value: "h4", label: "\uAC1C\uC694 4" },
      { value: "h5", label: "\uAC1C\uC694 5" },
      { value: "h6", label: "\uAC1C\uC694 6" }
    ];
    for (const s of styles) {
      styleSelect.createEl("option", { text: s.label, value: s.value });
    }
    styleSelect.addEventListener("change", (e) => {
      const target = e.target;
      const value = target.value;
      if (value === "p") {
        const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (view) {
          const editor = view.editor;
          const cursor = editor.getCursor();
          const line = editor.getLine(cursor.line);
          editor.setLine(cursor.line, line.replace(/^#{1,6}\s+/, ""));
        }
      } else {
        const level = parseInt(value.replace("h", ""), 10);
        if (this.execCmd(`obsidian-hwp-writer:set-heading-${level}`)) {
          this.setLastHeadingPattern(level);
        }
      }
      target.value = "p";
    });
    el.createDiv("hwp-toolbar-divider");
    const quickGroup = el.createDiv("hwp-toolbar-group");
    this.formatBrushButton = this.addButton(
      quickGroup,
      "paintbrush",
      "\uC11C\uC2DD \uBE0C\uB7EC\uC2DC",
      () => this.toggleFormatBrush()
    );
    this.addButton(quickGroup, "eraser", "\uC11C\uC2DD \uC9C0\uC6B0\uAE30", () => {
      this.runEditorCommand(["editor:clear-formatting"], "obsidian-hwp-writer:clear-formatting");
    });
    this.addButton(quickGroup, "heading-2", "\uC81C\uBAA9 2", () => {
      if (this.runEditorCommand(["editor:set-heading-2"], "obsidian-hwp-writer:set-heading-2")) {
        this.setLastHeadingPattern(2);
      }
    }, "H2");
    this.addButton(quickGroup, "heading-3", "\uC81C\uBAA9 3", () => {
      if (this.runEditorCommand(["editor:set-heading-3"], "obsidian-hwp-writer:set-heading-3")) {
        this.setLastHeadingPattern(3);
      }
    }, "H3");
    this.addMenuButton(quickGroup, "Hn", "\uCD94\uAC00 \uC81C\uBAA9 \uB808\uBCA8", [
      {
        label: "\uC81C\uBAA9 1",
        onClick: () => {
          if (this.runEditorCommand(["editor:set-heading-1"], "obsidian-hwp-writer:set-heading-1")) {
            this.setLastHeadingPattern(1);
          }
        }
      },
      {
        label: "\uC81C\uBAA9 4",
        onClick: () => {
          if (this.runEditorCommand(["editor:set-heading-4"], "obsidian-hwp-writer:set-heading-4")) {
            this.setLastHeadingPattern(4);
          }
        }
      },
      {
        label: "\uC81C\uBAA9 5",
        onClick: () => {
          if (this.runEditorCommand(["editor:set-heading-5"], "obsidian-hwp-writer:set-heading-5")) {
            this.setLastHeadingPattern(5);
          }
        }
      },
      {
        label: "\uC81C\uBAA9 6",
        onClick: () => {
          if (this.runEditorCommand(["editor:set-heading-6"], "obsidian-hwp-writer:set-heading-6")) {
            this.setLastHeadingPattern(6);
          }
        }
      }
    ]);
    el.createDiv("hwp-toolbar-divider");
    const textGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(textGroup, "bold-glyph", "\uAD75\uAC8C (Ctrl+B)", () => {
      if (this.runEditorCommand(["editor:toggle-bold"])) {
        this.setLastBrushPattern("\uAD75\uAC8C", (text) => `**${text}**`);
      }
    }, "B");
    this.addButton(textGroup, "italic-glyph", "\uAE30\uC6B8\uC784 (Ctrl+I)", () => {
      if (this.runEditorCommand(["editor:toggle-italics"])) {
        this.setLastBrushPattern("\uAE30\uC6B8\uC784", (text) => `*${text}*`);
      }
    }, "I");
    this.addButton(textGroup, "strikethrough-glyph", "\uCDE8\uC18C\uC120", () => {
      if (this.runEditorCommand(["editor:toggle-strikethrough"])) {
        this.setLastBrushPattern("\uCDE8\uC18C\uC120", (text) => `~~${text}~~`);
      }
    }, "S");
    this.addButton(textGroup, "underline-glyph", "\uBC11\uC904", () => {
      this.runEditorCommand(["editor:toggle-underline"], "obsidian-hwp-writer:toggle-underline");
    }, "U");
    this.addButton(textGroup, "highlighter", "\uD615\uAD11\uD39C", () => {
      if (this.runEditorCommand(["editor:toggle-highlight"])) {
        this.setLastBrushPattern("\uD615\uAD11\uD39C", (text) => `==${text}==`);
      }
    });
    el.createDiv("hwp-toolbar-divider");
    const toolsGroup = el.createDiv("hwp-toolbar-group");
    this.addMenuButton(toolsGroup, "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C", "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C", [
      { label: "\uC21C\uC218 \uD14D\uC2A4\uD2B8", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-get-plain") },
      { label: "\uC804\uAC01/\uBC18\uAC01 \uBCC0\uD658", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-smart-symbols") },
      { divider: true },
      { label: "\uBE48 \uC904 \uC0BD\uC785", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-insert-blank-lines") },
      { label: "\uBE48 \uC904 \uC81C\uAC70", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-remove-blank-lines") },
      { label: "\uC904 \uBD84\uD560", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-split-lines") },
      { label: "\uC904 \uD569\uCE58\uAE30", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-merge-lines") },
      { label: "\uC911\uBCF5 \uC904 \uC81C\uAC70", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-dedupe-lines") },
      { divider: true },
      { label: "\uC811\uB450/\uC811\uBBF8 \uCD94\uAC00", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-add-wrap") },
      { label: "\uC904 \uBC88\uD638 \uB9E4\uAE30\uAE30", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-number-lines") },
      { label: "\uC904 \uB05D \uACF5\uBC31 \uC81C\uAC70", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-trim-line-ends") },
      { label: "\uC5F0\uC18D \uACF5\uBC31 \uC555\uCD95", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-compress-spaces") },
      { label: "\uBAA8\uB4E0 \uACF5\uBC31 \uC81C\uAC70", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-remove-all-whitespace") },
      { divider: true },
      { label: "\uBAA9\uB85D \u2192 \uD45C", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-list-to-table") },
      { label: "\uD45C \u2192 \uBAA9\uB85D", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-table-to-list") },
      { label: "\uBB38\uC790\uC5F4 \uC0AC\uC774 \uCD94\uCD9C", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:text-extract-between") }
    ]);
    this.addMenuButton(toolsGroup, "\uC0BD\uC785/\uC218\uC2DD", "\uC0BD\uC785/\uC218\uC2DD", [
      {
        label: "\uC704 \uCCA8\uC790",
        onClick: () => {
          this.runEditorCommand([], "obsidian-hwp-writer:superscript");
        }
      },
      {
        label: "\uC544\uB798 \uCCA8\uC790",
        onClick: () => {
          this.runEditorCommand([], "obsidian-hwp-writer:subscript");
        }
      },
      { divider: true },
      {
        label: "\uC778\uB77C\uC778 \uCF54\uB4DC",
        onClick: () => {
          if (this.runEditorCommand(["editor:toggle-code"])) {
            this.setLastBrushPattern("\uC778\uB77C\uC778 \uCF54\uB4DC", (text) => `\`${text}\``);
          }
        }
      },
      { label: "\uCF54\uB4DC \uBE14\uB85D", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:insert-codeblock") },
      { divider: true },
      { label: "\uC704\uD0A4\uB9C1\uD06C", onClick: () => this.runEditorCommand(["editor:insert-wikilink"], "obsidian-hwp-writer:insert-wikilink") },
      { label: "\uC784\uBCA0\uB4DC", onClick: () => this.runEditorCommand(["editor:insert-embed"], "obsidian-hwp-writer:insert-embed") },
      { label: "\uB9C1\uD06C", onClick: () => this.runEditorCommand(["editor:insert-link"], "obsidian-hwp-writer:insert-link") },
      { divider: true },
      {
        label: "\uC778\uB77C\uC778 \uC218\uC2DD",
        onClick: () => {
          if (this.runEditorCommand([], "obsidian-hwp-writer:toggle-inline-math")) {
            this.setLastBrushPattern("\uC778\uB77C\uC778 \uC218\uC2DD", (text) => `$${text}$`);
          }
        }
      },
      { label: "\uC218\uC2DD \uBE14\uB85D", onClick: () => this.runEditorCommand(["editor:insert-mathblock"], "obsidian-hwp-writer:insert-mathblock") }
    ]);
    el.createDiv("hwp-toolbar-divider");
    const listGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(listGroup, "list", "\uAE00\uBA38\uB9AC \uBAA9\uB85D", () => {
      this.runEditorCommand(["editor:toggle-bullet-list"]);
    });
    this.addButton(listGroup, "list-ordered", "\uBC88\uD638 \uBAA9\uB85D", () => {
      this.runEditorCommand(["editor:toggle-numbered-list"]);
    });
    this.addButton(listGroup, "check-square", "\uCCB4\uD06C\uB9AC\uC2A4\uD2B8", () => {
      this.runEditorCommand(["editor:toggle-checklist-status"]);
    });
    this.addButton(listGroup, "check-circle", "\uBAA9\uB85D/\uCCB4\uD06C\uB9AC\uC2A4\uD2B8 \uC21C\uD658", () => {
      this.runEditorCommand(["editor:cycle-list-checklist"], "obsidian-hwp-writer:cycle-list-checklist");
    });
    el.createDiv("hwp-toolbar-divider");
    const quoteGroup = el.createDiv("hwp-toolbar-group");
    this.addMenuButton(quoteGroup, "\uC778\uC6A9/\uCF5C\uC544\uC6C3", "\uC778\uC6A9/\uCF5C\uC544\uC6C3", [
      { label: "\uC778\uC6A9\uBB38", onClick: () => this.runEditorCommand(["editor:toggle-blockquote"], "obsidian-hwp-writer:toggle-blockquote") },
      { label: "\uCF5C\uC544\uC6C3 (\uB178\uD2B8)", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:insert-callout-note") },
      { label: "\uCF5C\uC544\uC6C3 (\uC8FC\uC758)", onClick: () => this.runEditorCommand([], "obsidian-hwp-writer:insert-callout-warning") }
    ]);
    this.addMenuButton(quoteGroup, "\uC815\uB82C", "\uC815\uB82C", [
      {
        label: "\uC67C\uCABD \uC815\uB82C",
        onClick: () => {
          this.runEditorCommand([], "obsidian-hwp-writer:align-left");
        }
      },
      {
        label: "\uAC00\uC6B4\uB370 \uC815\uB82C",
        onClick: () => {
          this.runEditorCommand([], "obsidian-hwp-writer:align-center");
        }
      },
      {
        label: "\uC624\uB978\uCABD \uC815\uB82C",
        onClick: () => {
          this.runEditorCommand([], "obsidian-hwp-writer:align-right");
        }
      },
      {
        label: "\uC591\uCABD \uB9DE\uCDA4",
        onClick: () => {
          this.runEditorCommand([], "obsidian-hwp-writer:align-justify");
        }
      }
    ]);
    el.createDiv("hwp-toolbar-divider");
    const colorGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(colorGroup, "palette", "\uAE00\uC790\uC0C9", () => {
      this.applyFontColorFromToolbar();
    }, "\uAE00\uC790\uC0C9");
    this.addButton(colorGroup, "highlighter", "\uBC30\uACBD\uC0C9", () => {
      this.applyBackgroundColorFromToolbar();
    }, "\uBC30\uACBD\uC0C9");
    el.createDiv("hwp-toolbar-divider");
    const indentGroup = el.createDiv("hwp-toolbar-group");
    this.addButton(indentGroup, "indent", "\uB4E4\uC5EC\uC4F0\uAE30", () => {
      this.runEditorCommand(["editor:indent-list"]);
    });
    this.addButton(indentGroup, "outdent", "\uB0B4\uC5B4\uC4F0\uAE30", () => {
      this.runEditorCommand(["editor:unindent-list"]);
    });
  }
  // -- 서식 브러시 --
  toggleFormatBrush() {
    var _a;
    const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!view) {
      new import_obsidian3.Notice("\uD65C\uC131 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const editor = view.editor;
    if (!this.formatBrushActive) {
      const source = editor.getSelection();
      const hasSelection = !!(source == null ? void 0 : source.trim());
      let pattern = null;
      if (hasSelection) {
        pattern = (_a = this.detectBrushPatternFromEditorContext(editor)) != null ? _a : this.detectBrushPattern(source);
      } else {
        pattern = this.detectBrushPatternFromEditorContext(editor);
        if (!pattern && this.lastBrushPattern && this.isMarkdownBrushPattern(this.lastBrushPattern)) {
          pattern = this.lastBrushPattern;
        }
      }
      if (!pattern) {
        new import_obsidian3.Notice("\uC11C\uC2DD\uC744 \uBA3C\uC800 \uD55C \uBC88 \uC801\uC6A9\uD558\uAC70\uB098, \uC11C\uC2DD\uC774 \uC788\uB294 \uD14D\uC2A4\uD2B8\uB97C \uC120\uD0DD\uD558\uC138\uC694.");
        return;
      }
      this.formatBrushActive = true;
      this.formatBrushApply = pattern.apply;
      this.formatBrushLabel = pattern.name;
      this.formatBrushArmedAt = Date.now();
      this.lastBrushAppliedSelection = "";
      this.updateFormatBrushButton();
      new import_obsidian3.Notice(`\uC11C\uC2DD \uBE0C\uB7EC\uC2DC ON: ${pattern.name} (\uC801\uC6A9\uD560 \uD14D\uC2A4\uD2B8\uB97C \uC120\uD0DD\uD558\uC138\uC694)`);
      return;
    }
    this.clearFormatBrush(true);
  }
  applyFormatBrushFromSelection() {
    if (!this.formatBrushActive || !this.formatBrushApply)
      return;
    if (Date.now() - this.formatBrushArmedAt < 180)
      return;
    const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!view)
      return;
    const editor = view.editor;
    const selection = editor.getSelection();
    if (!selection || !selection.trim())
      return;
    const cursor = editor.getCursor();
    const signature = `${cursor.line}:${cursor.ch}:${selection}`;
    if (signature === this.lastBrushAppliedSelection)
      return;
    this.lastBrushAppliedSelection = signature;
    editor.replaceSelection(this.formatBrushApply(selection));
  }
  detectBrushPattern(selection) {
    const trimmed = selection.trim();
    if (!trimmed)
      return null;
    let working = trimmed;
    let headingLevel = null;
    const headingMatch = working.match(/^(#{1,6})\s+([\s\S]*)$/);
    if (headingMatch) {
      headingLevel = headingMatch[1].length;
      working = headingMatch[2];
    }
    const wrappers = [];
    let matched = true;
    while (matched && working.length > 0) {
      matched = false;
      for (const token of INLINE_MARKDOWN_TOKENS) {
        const minLength = token.open.length + token.close.length;
        if (working.length <= minLength)
          continue;
        if (!working.startsWith(token.open) || !working.endsWith(token.close))
          continue;
        working = working.slice(token.open.length, working.length - token.close.length);
        wrappers.push(token);
        matched = true;
        break;
      }
    }
    if (!headingLevel && wrappers.length === 0)
      return null;
    wrappers.reverse();
    return this.buildBrushPattern(headingLevel, wrappers);
  }
  detectBrushPatternFromEditorContext(editor) {
    var _a, _b, _c, _d, _e, _f;
    try {
      const from = (_c = (_a = editor.getCursor) == null ? void 0 : _a.call(editor, "from")) != null ? _c : (_b = editor.getCursor) == null ? void 0 : _b.call(editor);
      const to = (_e = (_d = editor.getCursor) == null ? void 0 : _d.call(editor, "to")) != null ? _e : from;
      if (!from || !to)
        return null;
      if (from.line !== to.line)
        return null;
      const line = (_f = editor.getLine) == null ? void 0 : _f.call(editor, from.line);
      if (typeof line !== "string")
        return null;
      const start = Math.min(from.ch, to.ch);
      const end = Math.max(from.ch, to.ch);
      const before = line.slice(0, start);
      const selected = line.slice(start, end);
      const after = line.slice(end);
      if (!selected)
        return null;
      let headingLevel = null;
      const headingMatch = line.match(/^\s{0,3}(#{1,6})\s+/);
      if (headingMatch) {
        const headingPrefixLength = headingMatch[0].length;
        if (start >= headingPrefixLength || start === 0 && end >= headingPrefixLength) {
          headingLevel = headingMatch[1].length;
        }
      }
      const wrappers = this.detectInlineMarkdownWrappers(before, after);
      if (!headingLevel && wrappers.length === 0)
        return null;
      return this.buildBrushPattern(headingLevel, wrappers);
    } catch (error) {
      console.warn("HWP toolbar brush context detection failed:", error);
    }
    return null;
  }
  detectInlineMarkdownWrappers(before, after) {
    const wrappers = [];
    let left = before;
    let right = after;
    let guard = 0;
    while (guard < 16) {
      guard += 1;
      const matched = INLINE_MARKDOWN_TOKENS.find(
        (token) => left.endsWith(token.open) && right.startsWith(token.close)
      );
      if (!matched)
        break;
      wrappers.push(matched);
      left = left.slice(0, left.length - matched.open.length);
      right = right.slice(matched.close.length);
    }
    return wrappers;
  }
  buildBrushPattern(headingLevel, wrappers) {
    const names = [];
    if (headingLevel)
      names.push(`\uC81C\uBAA9 ${headingLevel}`);
    for (const token of wrappers) {
      if (!names.includes(token.name))
        names.push(token.name);
    }
    return {
      name: names.join(" + "),
      apply: (text) => {
        let next = text;
        for (const token of wrappers) {
          next = `${token.open}${next}${token.close}`;
        }
        if (headingLevel) {
          next = this.applyHeadingToText(next, headingLevel);
        }
        return next;
      }
    };
  }
  applyHeadingToText(text, level) {
    const prefix = `${"#".repeat(level)} `;
    return text.split("\n").map((line) => {
      if (!line.trim())
        return line;
      const withoutHeading = line.replace(/^\s{0,3}#{1,6}\s+/, "");
      return `${prefix}${withoutHeading}`;
    }).join("\n");
  }
  clearFormatBrush(showNotice) {
    this.formatBrushActive = false;
    this.formatBrushApply = null;
    this.formatBrushLabel = "";
    this.formatBrushArmedAt = 0;
    this.lastBrushAppliedSelection = "";
    this.updateFormatBrushButton();
    if (showNotice)
      new import_obsidian3.Notice("\uC11C\uC2DD \uBE0C\uB7EC\uC2DC OFF");
  }
  updateFormatBrushButton() {
    if (!this.formatBrushButton)
      return;
    this.formatBrushButton.classList.toggle("is-active", this.formatBrushActive);
  }
  setLastBrushPattern(name, apply) {
    this.lastBrushPattern = { name, apply };
  }
  setLastHeadingPattern(level) {
    this.setLastBrushPattern(`\uC81C\uBAA9 ${level}`, (text) => this.applyHeadingToText(text, level));
  }
  isMarkdownBrushPattern(pattern) {
    try {
      const preview = pattern.apply("x");
      return !preview.includes("<");
    } catch (e) {
      return false;
    }
  }
  applyFontColorFromToolbar() {
    const editor = this.getActiveEditor();
    if (!editor) {
      new import_obsidian3.Notice("\uD65C\uC131 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    this.focusEditor();
    this.openColorPicker("#1a73e8", (color) => {
      this.applyInlineWrapToSelectionOrLine(editor, (text) => {
        const unwrapped = text.replace(/<font\s+color=["']?[^"'>]+["']?>([\s\S]*?)<\/font>/gi, "$1");
        return `<font color="${color}">${unwrapped}</font>`;
      });
    });
  }
  applyBackgroundColorFromToolbar() {
    const editor = this.getActiveEditor();
    if (!editor) {
      new import_obsidian3.Notice("\uD65C\uC131 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    this.focusEditor();
    this.openColorPicker("#fff59d", (color) => {
      this.applyInlineWrapToSelectionOrLine(editor, (text) => {
        const unwrapped = text.replace(
          /<mark\s+style=["']?background:[^"'>]+["']?>([\s\S]*?)<\/mark>/gi,
          "$1"
        );
        return `<mark style="background:${color}">${unwrapped}</mark>`;
      });
    });
  }
  openColorPicker(initialColor, onPick) {
    const input = document.createElement("input");
    input.type = "color";
    input.value = initialColor;
    input.style.position = "fixed";
    input.style.opacity = "0";
    input.style.pointerEvents = "none";
    input.style.width = "1px";
    input.style.height = "1px";
    input.style.left = "-100px";
    input.style.top = "-100px";
    document.body.appendChild(input);
    const cleanup = () => {
      input.removeEventListener("change", onChange);
      input.removeEventListener("input", onInput);
      if (input.parentElement)
        input.parentElement.removeChild(input);
    };
    let picked = false;
    const onInput = () => {
      picked = true;
      onPick(input.value);
    };
    const onChange = () => {
      picked = true;
      onPick(input.value);
      cleanup();
    };
    input.addEventListener("input", onInput);
    input.addEventListener("change", onChange);
    input.click();
    window.setTimeout(() => {
      if (!picked)
        cleanup();
    }, 1500);
  }
  applyInlineWrapToSelectionOrLine(editor, wrapper) {
    var _a, _b, _c;
    const selection = (_b = (_a = editor.getSelection) == null ? void 0 : _a.call(editor)) != null ? _b : "";
    if (selection && selection.length > 0) {
      editor.replaceSelection(wrapper(selection));
      return;
    }
    const cursor = (_c = editor.getCursor) == null ? void 0 : _c.call(editor);
    if (!cursor)
      return;
    const lineText = editor.getLine(cursor.line);
    editor.setLine(cursor.line, wrapper(lineText));
  }
  // -- 드롭다운 메뉴 --
  addMenuButton(parent, triggerLabel, tooltip, items) {
    var _a, _b;
    const menu = parent.createDiv("hwp-toolbar-menu");
    this.addButton(menu, "chevron-down", tooltip, () => this.toggleMenu(menu), triggerLabel);
    const panel = menu.createDiv("hwp-toolbar-menu-panel");
    for (const item of items) {
      if (item.divider) {
        panel.createDiv("hwp-toolbar-menu-divider");
        continue;
      }
      const btn = panel.createEl("button", {
        cls: "hwp-toolbar-menu-item",
        attr: { title: (_a = item.label) != null ? _a : "", "aria-label": (_b = item.label) != null ? _b : "" }
      });
      if (item.icon) {
        (0, import_obsidian3.setIcon)(btn, item.icon);
      }
      if (item.label) {
        btn.createSpan({ text: item.label });
      }
      btn.addEventListener("mousedown", (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
      });
      btn.addEventListener("click", (evt) => {
        var _a2;
        evt.preventDefault();
        evt.stopPropagation();
        this.closeMenu();
        (_a2 = item.onClick) == null ? void 0 : _a2.call(item);
      });
    }
  }
  toggleMenu(menu) {
    const willOpen = !menu.classList.contains("is-open");
    if (this.openMenu && this.openMenu !== menu) {
      this.openMenu.classList.remove("is-open");
    }
    menu.classList.toggle("is-open", willOpen);
    this.openMenu = willOpen ? menu : null;
  }
  closeMenu() {
    if (!this.openMenu)
      return;
    this.openMenu.classList.remove("is-open");
    this.openMenu = null;
  }
  // -- 헬퍼 --
  addButton(parent, icon, tooltip, onClick, label) {
    const btn = parent.createEl("button", {
      cls: "hwp-toolbar-btn",
      attr: { "aria-label": tooltip, title: tooltip }
    });
    if (label) {
      btn.createSpan({ text: label, cls: "hwp-toolbar-btn-label" });
    } else {
      (0, import_obsidian3.setIcon)(btn, icon);
    }
    btn.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      onClick();
    });
    return btn;
  }
  getActiveEditor() {
    var _a;
    const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    return (_a = view == null ? void 0 : view.editor) != null ? _a : null;
  }
  focusEditor() {
    var _a;
    const editor = this.getActiveEditor();
    (_a = editor == null ? void 0 : editor.focus) == null ? void 0 : _a.call(editor);
  }
  handleUndo() {
    const editor = this.getActiveEditor();
    if (editor && typeof editor.undo === "function") {
      editor.undo();
      return;
    }
    this.runEditorCommand(["editor:undo", "editing-toolbar:editor-undo"]);
  }
  handleRedo() {
    const editor = this.getActiveEditor();
    if (editor && typeof editor.redo === "function") {
      editor.redo();
      return;
    }
    this.runEditorCommand(["editor:redo", "editing-toolbar:editor-redo"]);
  }
  runEditorCommand(commandIds, fallbackCommandId) {
    this.focusEditor();
    for (const id of commandIds) {
      if (this.execCmd(id))
        return true;
    }
    if (fallbackCommandId)
      return this.execCmd(fallbackCommandId);
    return false;
  }
  execCmd(id) {
    var _a;
    try {
      return !!((_a = this.plugin.app.commands) == null ? void 0 : _a.executeCommandById(id));
    } catch (err) {
      console.warn("HWP toolbar command failed:", id, err);
      return false;
    }
  }
};

// src/toolbar/commands.ts
var import_obsidian4 = require("obsidian");
function runOnSelectionOrDocument(editor, transform) {
  const selection = editor.getSelection();
  if (selection.length > 0) {
    editor.replaceSelection(transform(selection));
    return;
  }
  const cursor = editor.getCursor();
  editor.setValue(transform(editor.getValue()));
  editor.setCursor(cursor);
}
function runOnSelectionOrCurrentLine(editor, transform) {
  const selection = editor.getSelection();
  if (selection.length > 0) {
    editor.replaceSelection(transform(selection));
    return;
  }
  const cursor = editor.getCursor();
  const line = editor.getLine(cursor.line);
  editor.setLine(cursor.line, transform(line));
}
function wrapOrUnwrapSelection(editor, open, close, placeholder) {
  const selection = editor.getSelection();
  if (selection.length > 0) {
    const trimmed = selection.trim();
    if (trimmed.startsWith(open) && trimmed.endsWith(close)) {
      const unwrapped = trimmed.slice(open.length, trimmed.length - close.length);
      editor.replaceSelection(unwrapped);
      return;
    }
    editor.replaceSelection(`${open}${selection}${close}`);
    return;
  }
  const cursor = editor.getCursor();
  const text = `${open}${placeholder}${close}`;
  editor.replaceRange(text, cursor);
  editor.setSelection(
    { line: cursor.line, ch: cursor.ch + open.length },
    { line: cursor.line, ch: cursor.ch + open.length + placeholder.length }
  );
}
function wrapLines(text, wrap) {
  return text.split("\n").map((line) => line.trim().length > 0 ? wrap(line) : line).join("\n");
}
function stripFormatting(text) {
  return text.replace(/<p\s+align=["']?(left|center|right|justify)["']?>([\s\S]*?)<\/p>/gi, "$2").replace(/<center>([\s\S]*?)<\/center>/gi, "$1").replace(/<\/?(?:u|sup|sub)>/gi, "").replace(/<font\s+color=["']?[^"'>]+["']?>([\s\S]*?)<\/font>/gi, "$1").replace(/<mark\s+style=["']?background:[^"'>]+["']?>([\s\S]*?)<\/mark>/gi, "$1").replace(/`([^`]+)`/g, "$1").replace(/\$([^$]+)\$/g, "$1").replace(/==([^=]+)==/g, "$1").replace(/~~([^~]+)~~/g, "$1").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/__([^_]+)__/g, "$1").replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "$1").replace(/(?<!_)_([^_]+)_(?!_)/g, "$1").replace(/^#{1,6}\s+/gm, "").replace(/^>\s?/gm, "");
}
function stripAlignWrapper(line) {
  return line.replace(/^<p\s+align=["']?(left|center|right|justify)["']?>([\s\S]*)<\/p>$/i, "$2").replace(/^<center>([\s\S]*)<\/center>$/i, "$1");
}
function applyAlignment(editor, align) {
  runOnSelectionOrCurrentLine(
    editor,
    (text) => wrapLines(text, (line) => `<p align="${align}">${stripAlignWrapper(line)}</p>`)
  );
}
function cycleListToChecklistFallback(editor) {
  runOnSelectionOrCurrentLine(
    editor,
    (text) => text.split("\n").map((line) => {
      if (/^\s*[-*+]\s+\[[xX ]\]\s+/.test(line)) {
        return line.replace(/^(\s*[-*+])\s+\[[xX ]\]\s+/, "$1 ");
      }
      if (/^\s*[-*+]\s+/.test(line)) {
        return line.replace(/^(\s*[-*+])\s+/, "$1 [ ] ");
      }
      if (/^\s*\d+\.\s+/.test(line)) {
        return line.replace(/^(\s*)\d+\.\s+/, "$1- [ ] ");
      }
      return line;
    }).join("\n")
  );
}
function listToTable(text) {
  const rows = text.split("\n").map((line) => line.trim()).filter((line) => line.length > 0).map((line) => line.replace(/^[-*+]\s+/, "").replace(/^\d+\.\s+/, "").trim()).filter((line) => line.length > 0);
  if (rows.length === 0)
    return text;
  const table = [
    "| \uD56D\uBAA9 |",
    "| --- |",
    ...rows.map((row) => `| ${row.replace(/\|/g, "\\|")} |`)
  ];
  return table.join("\n");
}
function tableToList(text) {
  const lines = text.split("\n").filter((line) => line.trim().length > 0);
  const tableLines = lines.filter((line) => line.includes("|"));
  if (tableLines.length < 2)
    return text;
  const body = tableLines.slice(2);
  if (body.length === 0)
    return text;
  const bullets = body.map((line) => {
    const cells = line.split("|").map((cell) => cell.trim()).filter((cell) => cell.length > 0);
    if (cells.length === 0)
      return "";
    return `- ${cells.join(" | ")}`;
  }).filter((line) => line.length > 0);
  return bullets.length > 0 ? bullets.join("\n") : text;
}
function toHalfWidth(text) {
  return text.replace(
    /[\uFF01-\uFF5E]/g,
    (char) => String.fromCharCode(char.charCodeAt(0) - 65248)
  ).replace(/\u3000/g, " ");
}
function toFullWidth(text) {
  return text.replace(/[!-~]/g, (char) => String.fromCharCode(char.charCodeAt(0) + 65248)).replace(/ /g, "\u3000");
}
function escapeRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function insertCallout(editor, type) {
  const title = type === "warning" ? "\uC8FC\uC758" : "\uBA54\uBAA8";
  const callout = `> [!${type}] ${title}
> \uB0B4\uC6A9\uC744 \uC785\uB825\uD558\uC138\uC694
`;
  const cursor = editor.getCursor();
  editor.replaceRange(callout, cursor);
}
function wrapInlineTag(editor, tag) {
  const open = `<${tag}>`;
  const close = `</${tag}>`;
  const placeholder = tag === "sup" ? "\uC704\uCCA8\uC790" : "\uC544\uB798\uCCA8\uC790";
  wrapOrUnwrapSelection(editor, open, close, placeholder);
}
function applyFontColor(editor) {
  const color = window.prompt("\uAE00\uC790\uC0C9\uC744 \uC785\uB825\uD558\uC138\uC694 (\uC608: #1a73e8, red)", "#1a73e8");
  if (!color)
    return;
  runOnSelectionOrCurrentLine(
    editor,
    (text) => wrapLines(
      text,
      (line) => `<font color="${color}">${line.replace(/<font\s+color=["']?[^"'>]+["']?>([\s\S]*?)<\/font>/gi, "$1")}</font>`
    )
  );
}
function applyBackgroundColor(editor) {
  const color = window.prompt("\uBC30\uACBD\uC0C9\uC744 \uC785\uB825\uD558\uC138\uC694 (\uC608: #fff59d, yellow)", "#fff59d");
  if (!color)
    return;
  runOnSelectionOrCurrentLine(
    editor,
    (text) => wrapLines(
      text,
      (line) => `<mark style="background:${color}">${line.replace(/<mark\s+style=["']?background:[^"'>]+["']?>([\s\S]*?)<\/mark>/gi, "$1")}</mark>`
    )
  );
}
function registerCommands(plugin) {
  for (let level = 1; level <= 6; level++) {
    plugin.addCommand({
      id: `set-heading-${level}`,
      name: `\uC81C\uBAA9 ${level} (H${level})`,
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const cleaned = line.replace(/^#{1,6}\s*/, "");
        const prefix = "#".repeat(level) + " ";
        editor.setLine(cursor.line, prefix + cleaned);
      }
    });
  }
  plugin.addCommand({
    id: "clear-formatting",
    name: "\uC11C\uC2DD \uC9C0\uC6B0\uAE30",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, stripFormatting);
    }
  });
  plugin.addCommand({
    id: "toggle-underline",
    name: "\uBC11\uC904",
    editorCallback: (editor) => {
      wrapOrUnwrapSelection(editor, "<u>", "</u>", "\uBC11\uC904 \uD14D\uC2A4\uD2B8");
    }
  });
  plugin.addCommand({
    id: "toggle-inline-math",
    name: "\uC778\uB77C\uC778 \uC218\uC2DD",
    editorCallback: (editor) => {
      wrapOrUnwrapSelection(editor, "$", "$", "x+y");
    }
  });
  plugin.addCommand({
    id: "superscript",
    name: "\uC704 \uCCA8\uC790",
    editorCallback: (editor) => wrapInlineTag(editor, "sup")
  });
  plugin.addCommand({
    id: "subscript",
    name: "\uC544\uB798 \uCCA8\uC790",
    editorCallback: (editor) => wrapInlineTag(editor, "sub")
  });
  plugin.addCommand({
    id: "insert-link",
    name: "\uB9C1\uD06C \uC0BD\uC785",
    editorCallback: (editor) => {
      const selection = editor.getSelection();
      if (selection.length > 0) {
        editor.replaceSelection(`[${selection}](https://)`);
        return;
      }
      const cursor = editor.getCursor();
      const linkText = "[\uB9C1\uD06C \uD14D\uC2A4\uD2B8](https://)";
      editor.replaceRange(linkText, cursor);
      editor.setSelection(
        { line: cursor.line, ch: cursor.ch + 1 },
        { line: cursor.line, ch: cursor.ch + 6 }
      );
    }
  });
  plugin.addCommand({
    id: "insert-wikilink",
    name: "\uC704\uD0A4\uB9C1\uD06C \uC0BD\uC785",
    editorCallback: (editor) => {
      const selection = editor.getSelection();
      if (selection.length > 0) {
        editor.replaceSelection(`[[${selection}]]`);
        return;
      }
      const cursor = editor.getCursor();
      editor.replaceRange("[[\uBB38\uC11C\uBA85]]", cursor);
    }
  });
  plugin.addCommand({
    id: "insert-embed",
    name: "\uC784\uBCA0\uB4DC \uC0BD\uC785",
    editorCallback: (editor) => {
      const selection = editor.getSelection();
      if (selection.length > 0) {
        editor.replaceSelection(`![[${selection}]]`);
        return;
      }
      const cursor = editor.getCursor();
      editor.replaceRange("![[\uCCA8\uBD80\uD30C\uC77C]]", cursor);
    }
  });
  plugin.addCommand({
    id: "insert-table",
    name: "\uD45C \uC0BD\uC785",
    editorCallback: (editor) => {
      const table = [
        "",
        "| \uC81C\uBAA9 1 | \uC81C\uBAA9 2 | \uC81C\uBAA9 3 |",
        "|--------|--------|--------|",
        "| \uB0B4\uC6A9 1 | \uB0B4\uC6A9 2 | \uB0B4\uC6A9 3 |",
        "| \uB0B4\uC6A9 4 | \uB0B4\uC6A9 5 | \uB0B4\uC6A9 6 |",
        ""
      ].join("\n");
      const cursor = editor.getCursor();
      editor.replaceRange(table, cursor);
    }
  });
  plugin.addCommand({
    id: "insert-hr",
    name: "\uC218\uD3C9\uC120 \uC0BD\uC785",
    editorCallback: (editor) => {
      const cursor = editor.getCursor();
      editor.replaceRange("\n---\n", cursor);
    }
  });
  plugin.addCommand({
    id: "insert-codeblock",
    name: "\uCF54\uB4DC\uBE14\uB85D \uC0BD\uC785",
    editorCallback: (editor) => {
      const selection = editor.getSelection();
      if (selection.length > 0) {
        editor.replaceSelection("```\n" + selection + "\n```");
      } else {
        const cursor = editor.getCursor();
        editor.replaceRange("```\n\n```", cursor);
        editor.setCursor({ line: cursor.line + 1, ch: 0 });
      }
    }
  });
  plugin.addCommand({
    id: "insert-mathblock",
    name: "\uC218\uC2DD \uBE14\uB85D \uC0BD\uC785",
    editorCallback: (editor) => {
      const selection = editor.getSelection();
      if (selection.length > 0) {
        editor.replaceSelection(`$$
${selection}
$$`);
      } else {
        const cursor = editor.getCursor();
        editor.replaceRange("$$\n\n$$", cursor);
        editor.setCursor({ line: cursor.line + 1, ch: 0 });
      }
    }
  });
  plugin.addCommand({
    id: "toggle-blockquote",
    name: "\uC778\uC6A9\uBB38 \uD1A0\uAE00",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").map(
          (line) => line.startsWith("> ") ? line.slice(2) : line.trim().length > 0 ? `> ${line}` : line
        ).join("\n")
      );
    }
  });
  plugin.addCommand({
    id: "insert-callout-note",
    name: "\uCF5C\uC544\uC6C3 \uC0BD\uC785 (\uB178\uD2B8)",
    editorCallback: (editor) => insertCallout(editor, "note")
  });
  plugin.addCommand({
    id: "insert-callout-warning",
    name: "\uCF5C\uC544\uC6C3 \uC0BD\uC785 (\uC8FC\uC758)",
    editorCallback: (editor) => insertCallout(editor, "warning")
  });
  plugin.addCommand({
    id: "align-left",
    name: "\uC67C\uCABD \uC815\uB82C",
    editorCallback: (editor) => applyAlignment(editor, "left")
  });
  plugin.addCommand({
    id: "align-center",
    name: "\uAC00\uC6B4\uB370 \uC815\uB82C",
    editorCallback: (editor) => applyAlignment(editor, "center")
  });
  plugin.addCommand({
    id: "align-right",
    name: "\uC624\uB978\uCABD \uC815\uB82C",
    editorCallback: (editor) => applyAlignment(editor, "right")
  });
  plugin.addCommand({
    id: "align-justify",
    name: "\uC591\uCABD \uB9DE\uCDA4",
    editorCallback: (editor) => applyAlignment(editor, "justify")
  });
  plugin.addCommand({
    id: "change-font-color",
    name: "\uAE00\uC790\uC0C9 \uBCC0\uACBD",
    editorCallback: (editor) => applyFontColor(editor)
  });
  plugin.addCommand({
    id: "change-background-color",
    name: "\uBC30\uACBD\uC0C9 \uBCC0\uACBD",
    editorCallback: (editor) => applyBackgroundColor(editor)
  });
  plugin.addCommand({
    id: "cycle-list-checklist",
    name: "\uBAA9\uB85D/\uCCB4\uD06C\uB9AC\uC2A4\uD2B8 \uC21C\uD658",
    editorCallback: (editor) => cycleListToChecklistFallback(editor)
  });
  plugin.addCommand({
    id: "text-get-plain",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC21C\uC218 \uD14D\uC2A4\uD2B8",
    editorCallback: (editor) => {
      runOnSelectionOrDocument(editor, stripFormatting);
      new import_obsidian4.Notice("\uC11C\uC2DD\uC744 \uC81C\uAC70\uD574 \uC21C\uC218 \uD14D\uC2A4\uD2B8\uB85C \uBCC0\uD658\uD588\uC2B5\uB2C8\uB2E4.");
    }
  });
  plugin.addCommand({
    id: "text-smart-symbols",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC804\uAC01/\uBC18\uAC01 \uBCC0\uD658",
    editorCallback: (editor) => {
      runOnSelectionOrDocument(editor, (text) => {
        const hasFullWidth = /[\uFF01-\uFF5E\u3000]/.test(text);
        return hasFullWidth ? toHalfWidth(text) : toFullWidth(text);
      });
    }
  });
  plugin.addCommand({
    id: "text-insert-blank-lines",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uBE48 \uC904 \uC0BD\uC785",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, (text) => text.split("\n").join("\n\n"));
    }
  });
  plugin.addCommand({
    id: "text-remove-blank-lines",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uBE48 \uC904 \uC81C\uAC70",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").filter((line) => line.trim().length > 0).join("\n")
      );
    }
  });
  plugin.addCommand({
    id: "text-split-lines",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC904 \uBD84\uD560",
    editorCallback: (editor) => {
      const separator = window.prompt("\uBD84\uD560 \uAE30\uC900 \uBB38\uC790\uB97C \uC785\uB825\uD558\uC138\uC694", ",");
      if (!separator)
        return;
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").flatMap((line) => line.split(separator)).map((line) => line.trim()).filter((line) => line.length > 0).join("\n")
      );
    }
  });
  plugin.addCommand({
    id: "text-merge-lines",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC904 \uD569\uCE58\uAE30",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").map((line) => line.trim()).filter((line) => line.length > 0).join(" ")
      );
    }
  });
  plugin.addCommand({
    id: "text-dedupe-lines",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC911\uBCF5 \uC904 \uC81C\uAC70",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, (text) => {
        const seen = /* @__PURE__ */ new Set();
        const out = [];
        for (const line of text.split("\n")) {
          if (!seen.has(line)) {
            seen.add(line);
            out.push(line);
          }
        }
        return out.join("\n");
      });
    }
  });
  plugin.addCommand({
    id: "text-add-wrap",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC811\uB450/\uC811\uBBF8 \uCD94\uAC00",
    editorCallback: (editor) => {
      var _a, _b;
      const prefix = (_a = window.prompt("\uC811\uB450\uC5B4", "")) != null ? _a : "";
      const suffix = (_b = window.prompt("\uC811\uBBF8\uC5B4", "")) != null ? _b : "";
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").map((line) => `${prefix}${line}${suffix}`).join("\n")
      );
    }
  });
  plugin.addCommand({
    id: "text-number-lines",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC904 \uBC88\uD638 \uB9E4\uAE30\uAE30",
    editorCallback: (editor) => {
      const startRaw = window.prompt("\uC2DC\uC791 \uBC88\uD638", "1");
      const start = startRaw ? Number(startRaw) : 1;
      const base = Number.isFinite(start) ? start : 1;
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").map((line, idx) => `${base + idx}. ${line}`).join("\n")
      );
    }
  });
  plugin.addCommand({
    id: "text-trim-line-ends",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC904 \uB05D \uACF5\uBC31 \uC81C\uAC70",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(
        editor,
        (text) => text.split("\n").map((line) => line.trimEnd()).join("\n")
      );
    }
  });
  plugin.addCommand({
    id: "text-compress-spaces",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uC5F0\uC18D \uACF5\uBC31 \uC555\uCD95",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, (text) => text.replace(/[ \t]{2,}/g, " "));
    }
  });
  plugin.addCommand({
    id: "text-remove-all-whitespace",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uBAA8\uB4E0 \uACF5\uBC31 \uC81C\uAC70",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, (text) => text.replace(/\s+/g, ""));
    }
  });
  plugin.addCommand({
    id: "text-list-to-table",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uBAA9\uB85D\u2192\uD45C",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, listToTable);
    }
  });
  plugin.addCommand({
    id: "text-table-to-list",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uD45C\u2192\uBAA9\uB85D",
    editorCallback: (editor) => {
      runOnSelectionOrCurrentLine(editor, tableToList);
    }
  });
  plugin.addCommand({
    id: "text-extract-between",
    name: "\uD14D\uC2A4\uD2B8 \uB3C4\uAD6C: \uBB38\uC790\uC5F4 \uC0AC\uC774 \uCD94\uCD9C",
    editorCallback: (editor) => {
      const start = window.prompt("\uC2DC\uC791 \uBB38\uC790\uC5F4", "");
      const end = window.prompt("\uB05D \uBB38\uC790\uC5F4", "");
      if (!start || !end)
        return;
      runOnSelectionOrCurrentLine(editor, (text) => {
        const pattern = new RegExp(
          `${escapeRegExp(start)}([\\s\\S]*?)${escapeRegExp(end)}`,
          "g"
        );
        const matches = [];
        let matched;
        while ((matched = pattern.exec(text)) !== null) {
          matches.push(matched[1]);
        }
        if (matches.length === 0) {
          new import_obsidian4.Notice("\uC77C\uCE58\uD558\uB294 \uAD6C\uAC04\uC744 \uCC3E\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4.");
          return text;
        }
        return matches.join("\n");
      });
    }
  });
  plugin.addCommand({
    id: "insert-image",
    name: "\uC774\uBBF8\uC9C0 \uC0BD\uC785",
    editorCallback: (editor) => {
      const cursor = editor.getCursor();
      editor.replaceRange("![[\uC774\uBBF8\uC9C0\uD30C\uC77C.png]]", cursor);
    }
  });
  plugin.addCommand({
    id: "move-line-up",
    name: "\uC904 \uC704\uB85C \uC774\uB3D9",
    editorCallback: (editor) => {
      const cursor = editor.getCursor();
      if (cursor.line === 0)
        return;
      const currentLine = editor.getLine(cursor.line);
      const prevLine = editor.getLine(cursor.line - 1);
      editor.setLine(cursor.line - 1, currentLine);
      editor.setLine(cursor.line, prevLine);
      editor.setCursor({ line: cursor.line - 1, ch: cursor.ch });
    }
  });
  plugin.addCommand({
    id: "move-line-down",
    name: "\uC904 \uC544\uB798\uB85C \uC774\uB3D9",
    editorCallback: (editor) => {
      const cursor = editor.getCursor();
      if (cursor.line >= editor.lineCount() - 1)
        return;
      const currentLine = editor.getLine(cursor.line);
      const nextLine = editor.getLine(cursor.line + 1);
      editor.setLine(cursor.line + 1, currentLine);
      editor.setLine(cursor.line, nextLine);
      editor.setCursor({ line: cursor.line + 1, ch: cursor.ch });
    }
  });
  plugin.addCommand({
    id: "duplicate-line",
    name: "\uC904 \uBCF5\uC81C",
    editorCallback: (editor) => {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      editor.replaceRange("\n" + line, { line: cursor.line, ch: line.length });
      editor.setCursor({ line: cursor.line + 1, ch: cursor.ch });
    }
  });
  plugin.addCommand({
    id: "insert-callout",
    name: "\uCF5C\uC544\uC6C3 \uC0BD\uC785",
    editorCallback: (editor) => insertCallout(editor, "note")
  });
}

// src/preview/PreviewView.ts
var import_obsidian5 = require("obsidian");

// src/converter/MarkdownPreprocessor.ts
var MarkdownPreprocessor = class {
  /**
   * 마크다운 → 블록 단위 전처리
   */
  preprocess(markdown) {
    const lines = markdown.split("\n");
    const result = [];
    let i = 0;
    while (i < lines.length) {
      const line = lines[i];
      const stripped = line.trim();
      if (!stripped) {
        result.push({ type: "empty", html: "", indent: 0 });
        i++;
        continue;
      }
      if (stripped.startsWith("```")) {
        const lang = stripped.slice(3).trim();
        const codeLines = [];
        i++;
        while (i < lines.length && !lines[i].trim().startsWith("```")) {
          codeLines.push(lines[i]);
          i++;
        }
        i++;
        const escaped = codeLines.join("\n").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        result.push({
          type: "codeblock",
          html: `<pre><code${lang ? ` class="language-${lang}"` : ""}>${escaped}</code></pre>`,
          indent: 0
        });
        continue;
      }
      if (stripped.startsWith("|") && stripped.endsWith("|")) {
        const tableLines = [];
        while (i < lines.length && lines[i].trim().startsWith("|") && lines[i].trim().endsWith("|")) {
          tableLines.push(lines[i].trim());
          i++;
        }
        const tableBlock = this.parseTable(tableLines);
        if (tableBlock) {
          result.push(tableBlock);
        } else {
          for (const tl of tableLines) {
            result.push({ type: "body", html: this.escapeHtml(tl), indent: 0 });
          }
        }
        continue;
      }
      if (/^[-*_]{3,}$/.test(stripped)) {
        result.push({ type: "hr", html: "", indent: 0 });
        i++;
        continue;
      }
      const headingMatch = stripped.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        const level = headingMatch[1].length;
        const html = this.inlineToHtml(headingMatch[2]);
        result.push({ type: `h${level}`, html, indent: 0 });
        i++;
        continue;
      }
      if (stripped.startsWith("> ")) {
        const html = this.inlineToHtml(stripped.slice(2));
        result.push({ type: "quote", html, indent: 0 });
        i++;
        continue;
      }
      const outlinePatterns = [
        { regex: /^(\d+)\.\s+(.+)$/, level: 2 },
        { regex: /^[가-힣]\.\s+(.+)$/, level: 3 },
        { regex: /^(\d+)\)\s+(.+)$/, level: 4 },
        { regex: /^[가-힣]\)\s+(.+)$/, level: 5 },
        { regex: /^\(\d+\)\s+(.+)$/, level: 6 },
        { regex: /^\([가-힣]\)\s+(.+)$/, level: 7 }
      ];
      let outlineMatched = false;
      for (const pattern of outlinePatterns) {
        const match = stripped.match(pattern.regex);
        if (match) {
          let content = match[1] + (pattern.regex.source.includes("\\)") && !pattern.regex.source.includes("\\(") ? ") " : pattern.regex.source.includes("\\(") ? ") " : ". ") + match[2];
          if (pattern.regex.source.includes("^\\(")) {
            content = "(" + content;
          }
          const rawContent = stripped;
          const html = this.inlineToHtml(rawContent);
          result.push({ type: `h${pattern.level}`, html, indent: 0 });
          outlineMatched = true;
          break;
        }
      }
      if (outlineMatched) {
        i++;
        continue;
      }
      const bulletMatch = stripped.match(/^[-*+]\s+(.+)$/);
      if (bulletMatch) {
        const rawIndent = line.length - line.trimStart().length;
        const indentLevel = Math.floor(rawIndent / 2);
        const html = this.inlineToHtml(bulletMatch[1]);
        result.push({ type: "list", html: `\u2022 ${html}`, indent: indentLevel });
        i++;
        continue;
      }
      const checkMatch = stripped.match(/^- \[([ xX])\]\s+(.+)$/);
      if (checkMatch) {
        const checked = checkMatch[1] !== " ";
        const icon = checked ? "\u2611" : "\u2610";
        const html = this.inlineToHtml(checkMatch[2]);
        result.push({ type: "list", html: `${icon} ${html}`, indent: 0 });
        i++;
        continue;
      }
      result.push({
        type: "body",
        html: this.inlineToHtml(stripped),
        indent: 0
      });
      i++;
    }
    return result;
  }
  /**
   * 마크다운 인라인 서식 → HTML 변환 (제거가 아님!)
   */
  inlineToHtml(text) {
    let r = text;
    r = r.replace(/&/g, "&amp;");
    r = r.replace(/</g, "&lt;");
    r = r.replace(/>/g, "&gt;");
    r = r.replace(
      /!\[([^\]]*)\]\(([^)]+)\)/g,
      '<img src="$2" alt="$1" style="max-width:100%;height:auto;" />'
    );
    r = r.replace(/\*\*\*(.+?)\*\*\*/g, "<strong><em>$1</em></strong>");
    r = r.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
    r = r.replace(/\*(.+?)\*/g, "<em>$1</em>");
    r = r.replace(/(?<!\w)_(.+?)_(?!\w)/g, "<em>$1</em>");
    r = r.replace(/~~(.+?)~~/g, "<del>$1</del>");
    r = r.replace(/==(.+?)==/g, '<mark style="background:#fef08a;padding:0 2px;">$1</mark>');
    r = r.replace(
      /`([^`]+)`/g,
      '<code style="background:#f1f5f9;padding:1px 4px;border-radius:3px;font-size:0.9em;">$1</code>'
    );
    r = r.replace(
      /\[\[([^\]]*?\|)(.+?)\]\]/g,
      '<span style="color:#4a86c8;text-decoration:underline;">$2</span>'
    );
    r = r.replace(
      /\[\[(.+?)\]\]/g,
      '<span style="color:#4a86c8;text-decoration:underline;">$1</span>'
    );
    r = r.replace(
      /\[(.+?)\]\((.+?)\)/g,
      '<a href="$2" style="color:#1a73e8;text-decoration:underline;" target="_blank">$1</a>'
    );
    return r;
  }
  /**
   * 마크다운 테이블 파싱 → PreprocessedBlock
   */
  parseTable(lines) {
    if (lines.length < 2)
      return null;
    let separatorIdx = -1;
    for (let i = 0; i < lines.length; i++) {
      const clean = lines[i].replace(/\|/g, "").trim();
      if (/^[-:\s]+$/.test(clean)) {
        separatorIdx = i;
        break;
      }
    }
    const parseCells = (line) => {
      return line.replace(/^\|/, "").replace(/\|$/, "").split("|").map((c) => this.inlineToHtml(c.trim()));
    };
    let headerRow = null;
    const dataRows = [];
    if (separatorIdx === 1) {
      headerRow = parseCells(lines[0]);
      for (let i = 2; i < lines.length; i++) {
        dataRows.push(parseCells(lines[i]));
      }
    } else {
      for (const line of lines) {
        const clean = line.replace(/\|/g, "").trim();
        if (!/^[-:\s]+$/.test(clean)) {
          dataRows.push(parseCells(line));
        }
      }
    }
    let tableHtml = '<table style="border-collapse:collapse;width:100%;margin:8px 0;">';
    if (headerRow) {
      tableHtml += "<thead><tr>";
      for (const cell of headerRow) {
        tableHtml += `<th style="border:1px solid #ccc;padding:6px 10px;background:#f0f4f8;font-weight:bold;text-align:left;">${cell}</th>`;
      }
      tableHtml += "</tr></thead>";
    }
    tableHtml += "<tbody>";
    for (let ri = 0; ri < dataRows.length; ri++) {
      const bg = ri % 2 === 1 ? "background:#fafbfc;" : "";
      tableHtml += `<tr style="${bg}">`;
      for (const cell of dataRows[ri]) {
        tableHtml += `<td style="border:1px solid #ccc;padding:6px 10px;">${cell}</td>`;
      }
      tableHtml += "</tr>";
    }
    tableHtml += "</tbody></table>";
    return {
      type: "table",
      html: tableHtml,
      indent: 0
    };
  }
  escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
};

// src/converter/HwpxStyleExtractor.ts
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var DEFAULT_HWPX_PAGE_LAYOUT = {
  // A4 + blank.hwpx 기본 여백 (HWPUNIT / 100)
  width_pt: 595.3,
  height_pt: 841.9,
  marginLeft_pt: 72,
  marginRight_pt: 72,
  marginTop_pt: 42.6,
  marginBottom_pt: 49.6
};
var DEFAULT_HWPX_STYLES = {
  "Normal": {
    fontFamily: "\uD568\uCD08\uB86C\uBC14\uD0D5",
    fontSize_pt: 10,
    bold: false,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "justify",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 160,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 0,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 1": {
    fontFamily: "HY\uD5E4\uB4DC\uB77C\uC778M",
    fontSize_pt: 25,
    bold: true,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "center",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 160,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 0,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 2": {
    fontFamily: "HY\uD5E4\uB4DC\uB77C\uC778M",
    fontSize_pt: 17,
    bold: true,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "center",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 0,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 3": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 15,
    bold: true,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 0,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 4": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 13,
    bold: true,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 0,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 5": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 13,
    bold: true,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 10,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 6": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 13,
    bold: false,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 15,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 7": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 12,
    bold: false,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 20,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 8": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 12,
    bold: false,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 25,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  },
  "Heading 9": {
    fontFamily: "\uD734\uBA3C\uBA85\uC870",
    fontSize_pt: 12,
    bold: false,
    italic: false,
    underline: false,
    strikeout: false,
    textColor: "#000000",
    charSpacing_pct: 0,
    charWidth_pct: 100,
    align: "left",
    lineSpacingType: "PERCENT",
    lineSpacing_pct: 180,
    lineSpacing_pt: null,
    marginLeft_pt: 0,
    marginRight_pt: 0,
    indent_pt: 30,
    spacingBefore_pt: 0,
    spacingAfter_pt: 0
  }
};
var EXTRACTOR_PY = `
import io
import json
import sys
import zipfile
import xml.etree.ElementTree as ET

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
hwpx_path = sys.argv[1]

ns = {
    'hh': 'http://www.hancom.co.kr/hwpml/2011/head',
    'hc': 'http://www.hancom.co.kr/hwpml/2011/core',
    'hp': 'http://www.hancom.co.kr/hwpml/2011/paragraph',
    'hs': 'http://www.hancom.co.kr/hwpml/2011/section',
}

def hwp_to_pt(val):
    return round(int(val) / 100.0, 1)

def _norm_zip_name(name):
    return name.replace(chr(92), '/').lower()

def find_zip_entry(zf, preferred_names, suffix_hint=None, must_contain='contents'):
    names = zf.namelist()
    normalized = [(_norm_zip_name(n), n) for n in names]

    for cand in preferred_names:
        cand_norm = _norm_zip_name(cand)
        for norm_name, original_name in normalized:
            if norm_name == cand_norm:
                return original_name

    if suffix_hint:
        suffix_norm = _norm_zip_name(suffix_hint)
        for norm_name, original_name in normalized:
            if norm_name.endswith(suffix_norm) and (must_contain in norm_name):
                return original_name

    return None

with zipfile.ZipFile(hwpx_path, 'r') as z:
    header_name = find_zip_entry(
        z,
        ['Contents/header.xml', 'Contents' + chr(92) + 'header.xml'],
        suffix_hint='header.xml'
    )
    if header_name is None:
        raise KeyError('header.xml not found in HWPX archive')
    header_xml = z.read(header_name).decode('utf-8-sig')

    section_name = find_zip_entry(
        z,
        ['Contents/section0.xml', 'Contents' + chr(92) + 'section0.xml'],
        suffix_hint='section0.xml'
    )
    section_xml = z.read(section_name).decode('utf-8-sig') if section_name else None

root = ET.fromstring(header_xml)
sec_root = ET.fromstring(section_xml) if section_xml else None

# 1) font id -> name
font_map = {}
for fontface in root.findall('.//hh:fontface', ns):
    for font in fontface.findall('hh:font', ns):
        fid = font.get('id', '')
        name = font.get('face', '')
        if fid and name:
            font_map[fid] = name

# 2) charPr map
char_pr_map = {}
for char_pr in root.findall('.//hh:charPr', ns):
    cid = char_pr.get('id')
    if not cid:
        continue

    height_val = int(char_pr.get('height', '1000'))
    text_color = char_pr.get('textColor', '#000000')

    bold = char_pr.find('.//hh:bold', ns) is not None
    italic = char_pr.find('.//hh:italic', ns) is not None

    underline = False
    underline_node = char_pr.find('.//hh:underline', ns)
    if underline_node is not None:
        u_type = (underline_node.get('type') or '').upper()
        underline = bool(u_type and u_type != 'NONE')

    strikeout = False
    strike_node = char_pr.find('.//hh:strikeout', ns)
    if strike_node is not None:
        s_type = (strike_node.get('type') or '').upper()
        strikeout = bool(s_type and s_type != 'NONE')

    font_name = '\uBC14\uD0D5'
    font_ref = char_pr.find('.//hh:fontRef', ns)
    if font_ref is not None:
        font_id = font_ref.get('hangul', '0')
        font_name = font_map.get(font_id, font_name)

    spacing_node = char_pr.find('.//hh:spacing', ns)
    spacing_val = int(spacing_node.get('hangul', '0')) if spacing_node is not None else 0

    ratio_node = char_pr.find('.//hh:ratio', ns)
    ratio_val = int(ratio_node.get('hangul', '100')) if ratio_node is not None else 100

    char_pr_map[cid] = {
        'fontSize_pt': height_val / 100.0,
        'textColor': text_color,
        'bold': bold,
        'italic': italic,
        'underline': underline,
        'strikeout': strikeout,
        'fontFamily': font_name,
        'charSpacing_pct': spacing_val,
        'charWidth_pct': ratio_val,
    }

# 3) paraPr map + outline level map
para_pr_map = {}
para_outline_level = {}

align_map = {
    'LEFT': 'left',
    'CENTER': 'center',
    'RIGHT': 'right',
    'JUSTIFY': 'justify',
    'DISTRIBUTE': 'justify',
}

for pp in root.findall('.//hh:paraPr', ns):
    pid = pp.get('id')
    if not pid:
        continue

    align_node = pp.find('hh:align', ns)
    align_raw = align_node.get('horizontal', 'LEFT') if align_node is not None else 'LEFT'
    align = align_map.get(align_raw, 'left')

    intent_val = 0
    left_val = 0
    right_val = 0
    prev_val = 0
    next_val = 0

    margin_nodes = pp.findall('.//hh:margin', ns)
    for margin in margin_nodes:
        intent_n = margin.find('hc:intent', ns)
        left_n = margin.find('hc:left', ns)
        right_n = margin.find('hc:right', ns)
        prev_n = margin.find('hc:prev', ns)
        next_n = margin.find('hc:next', ns)

        if intent_n is not None:
            intent_val = int(intent_n.get('value', '0'))
        if left_n is not None:
            left_val = int(left_n.get('value', '0'))
        if right_n is not None:
            right_val = int(right_n.get('value', '0'))
        if prev_n is not None:
            prev_val = int(prev_n.get('value', '0'))
        if next_n is not None:
            next_val = int(next_n.get('value', '0'))
        break

    line_spacing_type = 'PERCENT'
    line_spacing_val = 160
    ls_nodes = pp.findall('.//hh:lineSpacing', ns)
    for ls in ls_nodes:
        line_spacing_type = (ls.get('type', 'PERCENT') or 'PERCENT').upper()
        line_spacing_val = int(ls.get('value', '160'))
        break

    if line_spacing_type == 'PERCENT':
        line_spacing_pct = line_spacing_val
        line_spacing_pt = None
    else:
        line_spacing_pct = None
        line_spacing_pt = hwp_to_pt(line_spacing_val)

    para_pr_map[pid] = {
        'align': align,
        'lineSpacingType': line_spacing_type,
        'lineSpacing_pct': line_spacing_pct,
        'lineSpacing_pt': line_spacing_pt,
        'marginLeft_pt': hwp_to_pt(left_val),
        'marginRight_pt': hwp_to_pt(right_val),
        'indent_pt': hwp_to_pt(intent_val),
        'spacingBefore_pt': hwp_to_pt(prev_val),
        'spacingAfter_pt': hwp_to_pt(next_val),
    }

    outline_level = None
    for heading in pp.findall('.//hh:heading', ns):
        if heading.get('type') == 'OUTLINE':
            level_str = heading.get('level')
            if level_str is not None:
                try:
                    outline_level = int(level_str)
                    break
                except ValueError:
                    pass
    if outline_level is not None:
        para_outline_level[pid] = outline_level

# 4) style combine
known_names = {'Normal', 'Title', 'Subtitle'}
for i in range(1, 10):
    known_names.add(f'Heading {i}')

result_styles = {}

for style in root.findall('.//hh:style', ns):
    sid = style.get('id', '')
    eng_name = (style.get('engName') or '').strip()
    pp_ref = style.get('paraPrIDRef', '0')
    cp_ref = style.get('charPrIDRef', '0')

    combined = {}
    combined.update(para_pr_map.get(pp_ref, {}))
    combined.update(char_pr_map.get(cp_ref, {}))

    if eng_name in known_names:
        result_styles[eng_name] = combined

    outline_level = para_outline_level.get(pp_ref)
    if outline_level is not None and 0 <= outline_level <= 8:
        result_styles[f'Heading {outline_level + 1}'] = combined

    if sid == '0' and 'Normal' not in result_styles:
        result_styles['Normal'] = combined

# 5) page layout from section0.xml
page_layout = {
    'width_pt': 595.3,
    'height_pt': 841.9,
    'marginLeft_pt': 72.0,
    'marginRight_pt': 72.0,
    'marginTop_pt': 42.6,
    'marginBottom_pt': 49.6,
}

if sec_root is not None:
    page_pr = sec_root.find('.//hp:pagePr', ns)
    if page_pr is not None:
        try:
            page_layout['width_pt'] = hwp_to_pt(page_pr.get('width', '59530'))
            page_layout['height_pt'] = hwp_to_pt(page_pr.get('height', '84190'))
        except Exception:
            pass

        margin_node = page_pr.find('hp:margin', ns)
        if margin_node is not None:
            try:
                page_layout['marginLeft_pt'] = hwp_to_pt(margin_node.get('left', '7200'))
                page_layout['marginRight_pt'] = hwp_to_pt(margin_node.get('right', '7200'))
                page_layout['marginTop_pt'] = hwp_to_pt(margin_node.get('top', '4255'))
                page_layout['marginBottom_pt'] = hwp_to_pt(margin_node.get('bottom', '4960'))
            except Exception:
                pass

print(json.dumps({'styles': result_styles, 'page': page_layout}, ensure_ascii=False))
`;
function normalizeStyle(raw, fallback) {
  return {
    fontFamily: typeof (raw == null ? void 0 : raw.fontFamily) === "string" && raw.fontFamily ? raw.fontFamily : fallback.fontFamily,
    fontSize_pt: Number.isFinite(raw == null ? void 0 : raw.fontSize_pt) ? Number(raw.fontSize_pt) : fallback.fontSize_pt,
    bold: !!(raw == null ? void 0 : raw.bold),
    italic: !!(raw == null ? void 0 : raw.italic),
    underline: !!(raw == null ? void 0 : raw.underline),
    strikeout: !!(raw == null ? void 0 : raw.strikeout),
    textColor: typeof (raw == null ? void 0 : raw.textColor) === "string" && raw.textColor ? raw.textColor : fallback.textColor,
    charSpacing_pct: Number.isFinite(raw == null ? void 0 : raw.charSpacing_pct) ? Number(raw.charSpacing_pct) : fallback.charSpacing_pct,
    charWidth_pct: Number.isFinite(raw == null ? void 0 : raw.charWidth_pct) ? Number(raw.charWidth_pct) : fallback.charWidth_pct,
    align: typeof (raw == null ? void 0 : raw.align) === "string" && raw.align ? raw.align : fallback.align,
    lineSpacingType: typeof (raw == null ? void 0 : raw.lineSpacingType) === "string" ? raw.lineSpacingType : fallback.lineSpacingType,
    lineSpacing_pct: (raw == null ? void 0 : raw.lineSpacing_pct) == null ? null : Number(raw.lineSpacing_pct),
    lineSpacing_pt: (raw == null ? void 0 : raw.lineSpacing_pt) == null ? null : Number(raw.lineSpacing_pt),
    marginLeft_pt: Number.isFinite(raw == null ? void 0 : raw.marginLeft_pt) ? Number(raw.marginLeft_pt) : fallback.marginLeft_pt,
    marginRight_pt: Number.isFinite(raw == null ? void 0 : raw.marginRight_pt) ? Number(raw.marginRight_pt) : fallback.marginRight_pt,
    indent_pt: Number.isFinite(raw == null ? void 0 : raw.indent_pt) ? Number(raw.indent_pt) : fallback.indent_pt,
    spacingBefore_pt: Number.isFinite(raw == null ? void 0 : raw.spacingBefore_pt) ? Number(raw.spacingBefore_pt) : fallback.spacingBefore_pt,
    spacingAfter_pt: Number.isFinite(raw == null ? void 0 : raw.spacingAfter_pt) ? Number(raw.spacingAfter_pt) : fallback.spacingAfter_pt
  };
}
function normalizeStyles(rawStyles) {
  const styles = {};
  const normalFallback = DEFAULT_HWPX_STYLES["Normal"];
  if (rawStyles && typeof rawStyles === "object") {
    for (const [name, raw] of Object.entries(rawStyles)) {
      if (!name)
        continue;
      const namedFallback = DEFAULT_HWPX_STYLES[name] || normalFallback;
      styles[name] = normalizeStyle(raw, namedFallback);
    }
  }
  for (const [name, fallback] of Object.entries(DEFAULT_HWPX_STYLES)) {
    if (!styles[name]) {
      styles[name] = fallback;
    }
  }
  if (!styles["Normal"]) {
    styles["Normal"] = normalFallback;
  }
  return styles;
}
function normalizePage(rawPage) {
  return {
    width_pt: Number.isFinite(rawPage == null ? void 0 : rawPage.width_pt) ? Number(rawPage.width_pt) : DEFAULT_HWPX_PAGE_LAYOUT.width_pt,
    height_pt: Number.isFinite(rawPage == null ? void 0 : rawPage.height_pt) ? Number(rawPage.height_pt) : DEFAULT_HWPX_PAGE_LAYOUT.height_pt,
    marginLeft_pt: Number.isFinite(rawPage == null ? void 0 : rawPage.marginLeft_pt) ? Number(rawPage.marginLeft_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginLeft_pt,
    marginRight_pt: Number.isFinite(rawPage == null ? void 0 : rawPage.marginRight_pt) ? Number(rawPage.marginRight_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginRight_pt,
    marginTop_pt: Number.isFinite(rawPage == null ? void 0 : rawPage.marginTop_pt) ? Number(rawPage.marginTop_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginTop_pt,
    marginBottom_pt: Number.isFinite(rawPage == null ? void 0 : rawPage.marginBottom_pt) ? Number(rawPage.marginBottom_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginBottom_pt
  };
}
function fallbackResult() {
  return {
    styles: DEFAULT_HWPX_STYLES,
    page: DEFAULT_HWPX_PAGE_LAYOUT
  };
}
async function extractHwpxTemplateData(hwpxPath, pythonPath = "python") {
  return new Promise((resolve) => {
    const os = require("os");
    const fs = require("fs");
    const tmpScript = path.join(os.tmpdir(), "hwpx_style_extract.py");
    fs.writeFileSync(tmpScript, EXTRACTOR_PY, "utf-8");
    (0, import_child_process.execFile)(
      pythonPath,
      [tmpScript, hwpxPath],
      { timeout: 15e3, maxBuffer: 1024 * 1024 },
      (err, stdout, stderr) => {
        var _a, _b;
        try {
          fs.unlinkSync(tmpScript);
        } catch (_) {
        }
        if (err) {
          console.error("HWPX template extraction error:", err.message, stderr);
          resolve(fallbackResult());
          return;
        }
        try {
          const raw = JSON.parse(stdout.trim());
          const rawStyles = (_a = raw == null ? void 0 : raw.styles) != null ? _a : raw;
          const rawPage = (_b = raw == null ? void 0 : raw.page) != null ? _b : {};
          const styles = normalizeStyles(rawStyles);
          const page = normalizePage(rawPage);
          console.log("[HwpxStyleExtractor] Extracted styles:", Object.keys(styles));
          console.log("[HwpxStyleExtractor] Extracted page:", page);
          resolve({ styles, page });
        } catch (parseErr) {
          console.error("HWPX template JSON parse error:", stdout, parseErr);
          resolve(fallbackResult());
        }
      }
    );
  });
}

// src/preview/PreviewView.ts
var PREVIEW_VIEW_TYPE = "hwp-preview-view";
var _PreviewView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.previewEl = null;
    this.renderVersion = 0;
    this.plugin = plugin;
    this.preprocessor = new MarkdownPreprocessor();
    this.updateDebounced = (0, import_obsidian5.debounce)(() => {
      void this.updatePreview();
    }, 300, true);
  }
  getViewType() {
    return PREVIEW_VIEW_TYPE;
  }
  getDisplayText() {
    return "HWP \uBBF8\uB9AC\uBCF4\uAE30";
  }
  getIcon() {
    return "eye";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("hwp-preview-container");
    const paperFrame = container.createDiv("hwp-paper-frame");
    this.previewEl = paperFrame.createDiv("hwp-paper");
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        if (this.plugin.settings.enableLivePreview) {
          this.updateDebounced();
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateDebounced();
      })
    );
    void this.updatePreview();
  }
  forceRefresh() {
    void this.updatePreview();
  }
  async updatePreview() {
    if (!this.previewEl)
      return;
    const requestId = ++this.renderVersion;
    const pageLayout = this.resolvePageLayout();
    this.applyPageLayout(pageLayout);
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!view) {
      this.previewEl.innerHTML = '<div class="hwp-preview-empty">\uB9C8\uD06C\uB2E4\uC6B4 \uD30C\uC77C\uC744 \uC5F4\uC5B4\uC8FC\uC138\uC694</div>';
      return;
    }
    const markdown = view.editor.getValue();
    if (!markdown.trim()) {
      this.previewEl.innerHTML = '<div class="hwp-preview-empty">\uB0B4\uC6A9\uC744 \uC785\uB825\uD558\uC138\uC694</div>';
      return;
    }
    if (this.plugin.pandocBridge) {
      try {
        const fullHtml = await this.plugin.pandocBridge.convertToHtml(markdown);
        if (!this.previewEl || requestId !== this.renderVersion)
          return;
        const html2 = this.renderPandocHtml(fullHtml);
        this.previewEl.innerHTML = html2;
        return;
      } catch (e) {
        console.warn("HWP Writer Preview: PandocToHtml \uC2E4\uD328, \uB85C\uCEEC \uD30C\uC11C\uB85C \uD3F4\uBC31", e);
      }
    }
    const blocks = this.preprocessor.preprocess(markdown);
    if (!this.previewEl || requestId !== this.renderVersion)
      return;
    const html = this.renderBlocks(blocks);
    this.previewEl.innerHTML = html;
  }
  /**
   * Pandoc HTML 문서에서 body를 추출하고 HWPX 템플릿 스타일로 덮어쓰기
   */
  renderPandocHtml(fullHtml) {
    const bodyMatch = fullHtml.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
    const bodyHtmlRaw = bodyMatch ? bodyMatch[1] : fullHtml;
    const bodyHtml = bodyHtmlRaw.replace(/<script[\s\S]*?<\/script>/gi, "");
    const cached = this.plugin.settings.cachedTemplateStyles;
    const styles = cached && Object.keys(cached).length > 0 ? cached : DEFAULT_HWPX_STYLES;
    const css = this.buildPandocTemplateCss(styles);
    return `<style>${css}</style><div class="hwp-pandoc-content">${bodyHtml}</div>`;
  }
  /**
   * Pandoc 기본 태그(h1/p/li/blockquote...)를 HWPX 템플릿 스타일로 매핑
   */
  buildPandocTemplateCss(styles) {
    const normal = styles["Normal"] || DEFAULT_HWPX_STYLES["Normal"];
    const h1 = styles["Heading 1"] || normal;
    const h2 = styles["Heading 2"] || normal;
    const h3 = styles["Heading 3"] || normal;
    const h4 = styles["Heading 4"] || normal;
    const h5 = styles["Heading 5"] || normal;
    const h6 = styles["Heading 6"] || normal;
    const scopedNormal = this.styleToCss(normal);
    return [
      `.hwp-pandoc-content{${scopedNormal};max-width:none !important;margin:0 !important;padding:0 !important;}`,
      `.hwp-pandoc-content p{${scopedNormal}}`,
      `.hwp-pandoc-content li{${scopedNormal}}`,
      `.hwp-pandoc-content h1{${this.styleToCss(h1)}}`,
      `.hwp-pandoc-content h2{${this.styleToCss(h2)}}`,
      `.hwp-pandoc-content h3{${this.styleToCss(h3)}}`,
      `.hwp-pandoc-content h4{${this.styleToCss(h4)}}`,
      `.hwp-pandoc-content h5{${this.styleToCss(h5)}}`,
      `.hwp-pandoc-content h6{${this.styleToCss(h6)}}`,
      `.hwp-pandoc-content blockquote{${scopedNormal};border-left:2px solid #4a86c8;padding-left:9pt;color:#555;}`,
      `.hwp-pandoc-content img{max-width:100%;height:auto;}`,
      `.hwp-pandoc-content table{border-collapse:collapse;width:100%;margin:8px 0;}`,
      `.hwp-pandoc-content th,.hwp-pandoc-content td{border:1px solid #ccc;padding:6px 10px;}`,
      `.hwp-pandoc-content th{background:#f0f4f8;font-weight:bold;}`,
      `.hwp-pandoc-content pre{background:#f8f9fa;padding:12px;border-radius:4px;overflow-x:auto;}`,
      `.hwp-pandoc-content code{font-family:'Consolas','D2Coding',monospace;}`
    ].join("\n");
  }
  resolvePageLayout() {
    const cached = this.plugin.settings.cachedTemplatePageLayout;
    return {
      width_pt: Number.isFinite(cached == null ? void 0 : cached.width_pt) ? Number(cached == null ? void 0 : cached.width_pt) : DEFAULT_HWPX_PAGE_LAYOUT.width_pt,
      height_pt: Number.isFinite(cached == null ? void 0 : cached.height_pt) ? Number(cached == null ? void 0 : cached.height_pt) : DEFAULT_HWPX_PAGE_LAYOUT.height_pt,
      marginLeft_pt: Number.isFinite(cached == null ? void 0 : cached.marginLeft_pt) ? Number(cached == null ? void 0 : cached.marginLeft_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginLeft_pt,
      marginRight_pt: Number.isFinite(cached == null ? void 0 : cached.marginRight_pt) ? Number(cached == null ? void 0 : cached.marginRight_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginRight_pt,
      marginTop_pt: Number.isFinite(cached == null ? void 0 : cached.marginTop_pt) ? Number(cached == null ? void 0 : cached.marginTop_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginTop_pt,
      marginBottom_pt: Number.isFinite(cached == null ? void 0 : cached.marginBottom_pt) ? Number(cached == null ? void 0 : cached.marginBottom_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginBottom_pt
    };
  }
  applyPageLayout(layout) {
    if (!this.previewEl)
      return;
    this.previewEl.style.width = `${layout.width_pt}pt`;
    this.previewEl.style.minHeight = `${layout.height_pt}pt`;
    this.previewEl.style.padding = `${layout.marginTop_pt}pt ${layout.marginRight_pt}pt ${layout.marginBottom_pt}pt ${layout.marginLeft_pt}pt`;
    this.previewEl.style.boxSizing = "border-box";
    const frame = this.previewEl.parentElement;
    if (frame) {
      frame.style.width = `${layout.width_pt}pt`;
      frame.style.maxWidth = "100%";
    }
  }
  /**
   * 전처리된 블록을 HWPX 템플릿 스타일로 HTML 렌더링
   */
  renderBlocks(blocks) {
    var _a, _b;
    const cached = this.plugin.settings.cachedTemplateStyles;
    const styles = cached && Object.keys(cached).length > 0 ? cached : DEFAULT_HWPX_STYLES;
    const normalStyle = styles["Normal"] || DEFAULT_HWPX_STYLES["Normal"];
    console.log("HWP Writer PreviewView: \uB80C\uB354\uB9C1 \uC2A4\uD0C0\uC77C", {
      source: cached && Object.keys(cached).length > 0 ? "cachedTemplateStyles" : "DEFAULT_HWPX_STYLES",
      normalFont: normalStyle.fontFamily,
      normalSize: normalStyle.fontSize_pt,
      h1Font: (_a = styles["Heading 1"]) == null ? void 0 : _a.fontFamily,
      h3Font: (_b = styles["Heading 3"]) == null ? void 0 : _b.fontFamily,
      sampleCSS: this.styleToCss(normalStyle)
    });
    let html = "";
    for (const block of blocks) {
      if (block.type === "empty") {
        html += `<div class="hwp-line hwp-empty" style="${this.styleToCss(normalStyle)}">&nbsp;</div>`;
        continue;
      }
      if (block.type === "hr") {
        html += '<hr style="border:none;border-top:1px solid #999;margin:12px 0;">';
        continue;
      }
      if (block.type === "table") {
        const tableWrapCss = `font-size:${normalStyle.fontSize_pt}pt !important;font-family:${this.fontFamilyToCss(normalStyle.fontFamily)} !important;`;
        html += `<div class="hwp-table-wrap" style="${tableWrapCss}">${block.html}</div>`;
        continue;
      }
      if (block.type === "codeblock") {
        html += `<div class="hwp-codeblock" style="margin:8px 0;font-size:${Math.max(normalStyle.fontSize_pt - 1, 8)}pt;">${block.html}</div>`;
        continue;
      }
      const hwpxStyleName = this.mapToHwpxStyle(block.type);
      const style = styles[hwpxStyleName] || normalStyle;
      let css = this.styleToCss(style, block.indent);
      if (block.type === "quote") {
        css += ";border-left:2px solid #4a86c8;padding-left:9pt;color:#555;";
      }
      if (block.type === "list") {
        const bulletPt = 12;
        css += `;text-indent:-${bulletPt}pt`;
        css += `;padding-left:${bulletPt}pt`;
      }
      html += `<div class="hwp-line hwp-${block.type}" style="${css}">${block.html}</div>`;
    }
    return html;
  }
  /**
   * 마크다운 타입 → HWPX 스타일 이름
   */
  mapToHwpxStyle(type) {
    switch (type) {
      case "h1":
        return "Heading 1";
      case "h2":
        return "Heading 2";
      case "h3":
        return "Heading 3";
      case "h4":
        return "Heading 4";
      case "h5":
        return "Heading 5";
      case "h6":
        return "Heading 6";
      case "h7":
        return "Heading 7";
      case "h8":
        return "Heading 8";
      case "h9":
        return "Heading 9";
      case "quote":
        return "Normal";
      case "list":
        return "Normal";
      case "body":
        return "Normal";
      default:
        return "Normal";
    }
  }
  /**
   * HWPX 폰트명 → CSS font-family 스택 반환
   */
  fontFamilyToCss(fontName) {
    if (_PreviewView.FONT_ALIASES[fontName]) {
      return _PreviewView.FONT_ALIASES[fontName];
    }
    return `'${fontName}','\uB9D1\uC740 \uACE0\uB515','Malgun Gothic',serif`;
  }
  /**
   * HwpxStyle → CSS 문자열 (정밀 매핑)
   * 
   * HWPX 템플릿의 모든 속성을 CSS로 변환:
   * - 글자: 글꼴, 크기, 굵기, 이탤릭, 색상, 장평, 자간
   * - 문단: 정렬, 줄간격, 여백, 들여쓰기, 문단 간격
   */
  styleToCss(style, indent = 0) {
    const parts = [];
    if (style.fontSize_pt)
      parts.push(`font-size:${style.fontSize_pt}pt !important`);
    if (style.fontFamily)
      parts.push(`font-family:${this.fontFamilyToCss(style.fontFamily)} !important`);
    if (style.bold)
      parts.push("font-weight:bold");
    if (style.italic)
      parts.push("font-style:italic");
    const textDecorations = [];
    if (style.underline)
      textDecorations.push("underline");
    if (style.strikeout)
      textDecorations.push("line-through");
    if (textDecorations.length > 0) {
      parts.push(`text-decoration:${textDecorations.join(" ")}`);
    }
    if (style.textColor && style.textColor !== "#000000" && style.textColor !== "none") {
      parts.push(`color:${style.textColor}`);
    }
    if (style.charSpacing_pct && style.charSpacing_pct !== 0) {
      parts.push(`letter-spacing:${(style.charSpacing_pct / 100).toFixed(2)}em`);
    }
    if (style.charWidth_pct && style.charWidth_pct !== 100) {
      parts.push(`font-stretch:${style.charWidth_pct}%`);
    }
    if (style.align)
      parts.push(`text-align:${style.align}`);
    if (style.lineSpacing_pt != null && style.lineSpacing_pt > 0) {
      parts.push(`line-height:${style.lineSpacing_pt}pt`);
    } else if (style.lineSpacing_pct && style.lineSpacing_pct > 0) {
      parts.push(`line-height:${(style.lineSpacing_pct / 100).toFixed(2)}`);
    }
    const ml = (style.marginLeft_pt || 0) + (indent > 0 ? indent * 20 : 0);
    if (ml > 0)
      parts.push(`margin-left:${ml}pt`);
    if (style.marginRight_pt && style.marginRight_pt > 0) {
      parts.push(`margin-right:${style.marginRight_pt}pt`);
    }
    if (style.indent_pt && style.indent_pt > 0 && indent === 0) {
      parts.push(`text-indent:${style.indent_pt}pt`);
    }
    if (style.spacingBefore_pt && style.spacingBefore_pt > 0) {
      parts.push(`margin-top:${style.spacingBefore_pt}pt`);
    }
    if (style.spacingAfter_pt && style.spacingAfter_pt > 0) {
      parts.push(`margin-bottom:${style.spacingAfter_pt}pt`);
    }
    return parts.join(";");
  }
  async onClose() {
    this.renderVersion++;
    this.previewEl = null;
  }
};
var PreviewView = _PreviewView;
/**
 * HWPX 내부 폰트명 → CSS font-family 스택 매핑
 * 
 * HWPX 템플릿은 한글 프로그램 내부 폰트명을 사용하지만,
 * Chromium(Obsidian)에서는 Windows 시스템 폰트명(한글/영문 모두)이 필요합니다.
 * 여기서 각 폰트의 별칭과 적절한 generic fallback을 지정합니다.
 */
PreviewView.FONT_ALIASES = {
  // 바탕 계열 (serif)
  "\uD568\uCD08\uB86C\uBC14\uD0D5": "'\uD568\uCD08\uB86C\uBC14\uD0D5','HCR Batang','Batang','\uBC14\uD0D5',serif",
  "\uD568\uCD08\uB86C\uB3CB\uC6C0": "'\uD568\uCD08\uB86C\uB3CB\uC6C0','HCR Dotum','Dotum','\uB3CB\uC6C0',sans-serif",
  "\uBC14\uD0D5": "'\uBC14\uD0D5','Batang',serif",
  "\uBC14\uD0D5\uCCB4": "'\uBC14\uD0D5\uCCB4','BatangChe',serif",
  // 명조 계열 (serif)
  "\uD734\uBA3C\uBA85\uC870": "'\uD734\uBA3C\uBA85\uC870','HY\uC2E0\uBA85\uC870','HYSinMyeongJo-Medium','HY Myeongjo','HYMyeongJo','Batang','\uBC14\uD0D5',serif",
  // 고딕 계열 (sans-serif)
  "\uB9D1\uC740 \uACE0\uB515": "'\uB9D1\uC740 \uACE0\uB515','Malgun Gothic',sans-serif",
  "\uB3CB\uC6C0": "'\uB3CB\uC6C0','Dotum',sans-serif",
  "\uB3CB\uC6C0\uCCB4": "'\uB3CB\uC6C0\uCCB4','DotumChe',sans-serif",
  "\uAD74\uB9BC": "'\uAD74\uB9BC','Gulim',sans-serif",
  "\uAD74\uB9BC\uCCB4": "'\uAD74\uB9BC\uCCB4','GulimChe',sans-serif",
  "\uB098\uB214\uACE0\uB515": "'\uB098\uB214\uACE0\uB515','NanumGothic',sans-serif",
  "\uB098\uB214\uBC14\uB978\uACE0\uB515": "'\uB098\uB214\uBC14\uB978\uACE0\uB515','NanumBarunGothic',sans-serif",
  "\uB098\uB214\uBA85\uC870": "'\uB098\uB214\uBA85\uC870','NanumMyeongjo',serif",
  "\uB098\uB214\uC2A4\uD018\uC5B4": "'\uB098\uB214\uC2A4\uD018\uC5B4','NanumSquare',sans-serif",
  "\uB098\uB214\uC2A4\uD018\uC5B4\uB77C\uC6B4\uB4DC": "'\uB098\uB214\uC2A4\uD018\uC5B4\uB77C\uC6B4\uB4DC','NanumSquareRound',sans-serif",
  // HY 계열
  "HY\uD5E4\uB4DC\uB77C\uC778M": "'HY\uD5E4\uB4DC\uB77C\uC778M','HYHeadLine-Medium','HY HeadLine M','HYHeadLineM','\uB9D1\uC740 \uACE0\uB515','Malgun Gothic',sans-serif",
  "HY\uC2E0\uBA85\uC870": "'HY\uC2E0\uBA85\uC870','HYSinMyeongJo-Medium','HY SinMyeongjo','\uBC14\uD0D5','Batang',serif",
  "HY\uACAC\uBA85\uC870": "'HY\uACAC\uBA85\uC870','HYMyeongJo-Extra','\uBC14\uD0D5','Batang',serif",
  "HY\uC911\uACE0\uB515": "'HY\uC911\uACE0\uB515','HYJungGothic-Medium','HY JungGothic','\uB3CB\uC6C0','Dotum',sans-serif",
  "HY\uACAC\uACE0\uB515": "'HY\uACAC\uACE0\uB515','HYGeonGothic-Bold','\uB3CB\uC6C0','Dotum',sans-serif",
  "HY\uADF8\uB798\uD53D": "'HY\uADF8\uB798\uD53D','HYGraphic-Medium','HYGraphic',sans-serif",
  "HY\uADF8\uB798\uD53DM": "'HY\uADF8\uB798\uD53DM','HYGraphic-Medium','HY\uADF8\uB798\uD53D','HYGraphic',sans-serif",
  "HY\uAD81\uC11CB": "'HY\uAD81\uC11CB','HYGungSo-Bold','HY GungSo B','\uAD81\uC11C','Gungsuh',serif",
  // 휴먼 계열
  "\uD734\uBA3C\uC61B\uCCB4": "'\uD734\uBA3C\uC61B\uCCB4','Yet R',serif",
  "\uD734\uBA3C\uD3B8\uC9C0\uCCB4": "'\uD734\uBA3C\uD3B8\uC9C0\uCCB4','Pyunji R',serif",
  "\uD734\uBA3C\uC544\uBBF8\uCCB4": "'\uD734\uBA3C\uC544\uBBF8\uCCB4','Ami R',sans-serif",
  // Pretendard (웹폰트, 시스템 설치 가능)
  "Pretendard": "'Pretendard','Pretendard Variable','\uB9D1\uC740 \uACE0\uB515','Malgun Gothic',sans-serif",
  // 궁서 계열
  "\uAD81\uC11C": "'\uAD81\uC11C','Gungsuh',serif",
  "\uAD81\uC11C\uCCB4": "'\uAD81\uC11C\uCCB4','GungsuhChe',serif",
  // 한컴 계열
  "\uD55C\uCEF4\uBC14\uD0D5": "'\uD55C\uCEF4\uBC14\uD0D5','HancomBatang','Hancom Batang','Batang','\uBC14\uD0D5',serif",
  "\uD55C\uCEF4\uB3CB\uC6C0": "'\uD55C\uCEF4\uB3CB\uC6C0','HancomDotum','Hancom Dotum','Dotum','\uB3CB\uC6C0',sans-serif"
};

// src/converter/PandocBridge.ts
var PandocBridge = class {
  constructor(settings, pluginDir, vaultBasePath) {
    this.settings = settings;
    this.pluginDir = pluginDir || "";
    this.vaultBasePath = vaultBasePath || "";
  }
  setPluginDir(dir) {
    this.pluginDir = dir;
  }
  setVaultBasePath(basePath) {
    this.vaultBasePath = basePath || "";
  }
  /**
   * 플러그인 폴더 내 기본 blank.hwpx 절대경로
   */
  getDefaultTemplatePath() {
    const path2 = require("path");
    return path2.join(this.pluginDir, "blank.hwpx");
  }
  /**
   * 현재 사용할 템플릿의 절대경로 반환
   * 사용자 선택 템플릿 > 플러그인 기본 blank.hwpx
   */
  getActiveTemplatePath() {
    const fs = require("fs");
    const path2 = require("path");
    if (this.settings.defaultTemplatePath) {
      if (this.vaultBasePath) {
        const candidate = path2.join(this.vaultBasePath, this.settings.defaultTemplatePath);
        if (fs.existsSync(candidate)) {
          return candidate;
        }
      }
    }
    const defaultPath = this.getDefaultTemplatePath();
    if (fs.existsSync(defaultPath)) {
      return defaultPath;
    }
    const devPath = path2.join(__dirname, "blank.hwpx");
    if (fs.existsSync(devPath)) {
      return devPath;
    }
    throw new Error(
      `\uAE30\uBCF8 \uD15C\uD50C\uB9BF(blank.hwpx)\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.
\uD655\uC778 \uACBD\uB85C: ${defaultPath}

blank.hwpx \uD30C\uC77C\uC744 \uD50C\uB7EC\uADF8\uC778 \uD3F4\uB354\uC5D0 \uBCF5\uC0AC\uD574\uC8FC\uC138\uC694.`
    );
  }
  /**
   * pypandoc-hwpx 설치 여부 확인
   */
  async checkHealth() {
    try {
      const result = await this.runPythonScript(
        'from pypandoc_hwpx.PandocToHwpx import PandocToHwpx\nfrom pypandoc_hwpx.PandocToHtml import PandocToHtml\nimport pypandoc\npypandoc.get_pandoc_path()\nprint("ok")'
      );
      return result.trim() === "ok";
    } catch (e) {
      return false;
    }
  }
  async startServer() {
    return await this.checkHealth();
  }
  async stopServer() {
  }
  /**
   * 마크다운 → HWPX 변환
   * 항상 템플릿 경로를 3번째 인자로 전달합니다.
   */
  async convert(markdown, settings) {
    const healthy = await this.checkHealth();
    if (!healthy) {
      throw new Error(
        `pypandoc-hwpx\uAC00 \uC124\uCE58\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.

\uB2E4\uC74C \uBA85\uB839\uC5B4\uB97C \uC2E4\uD589\uD574\uC8FC\uC138\uC694:
  ${this.settings.pythonPath} -m pip install pypandoc pypandoc-hwpx pillow

Pandoc\uB3C4 \uC124\uCE58\uB418\uC5B4 \uC788\uC5B4\uC57C \uD569\uB2C8\uB2E4:
  https://pandoc.org/installing.html`
      );
    }
    const fs = require("fs");
    const path2 = require("path");
    const os = require("os");
    const tmpDir = os.tmpdir();
    const timestamp = Date.now();
    const inputPath = path2.join(tmpDir, `hwp_writer_${timestamp}.md`);
    const outputPath = path2.join(tmpDir, `hwp_writer_${timestamp}.hwpx`);
    const templatePath = this.getActiveTemplatePath();
    try {
      fs.writeFileSync(inputPath, markdown, "utf-8");
      const escapePath = (p) => p.replace(/\\/g, "\\\\");
      const pyCode = [
        `import sys`,
        `from pypandoc_hwpx.PandocToHwpx import PandocToHwpx`,
        // pypandoc_hwpx(일부 버전) 헤더 매핑 버그 보정:
        // # (Header1)이 Heading2로 밀리는 문제를 런타임에서 교정.
        `def _hwp_writer_fix_handle_header(self, content):`,
        `    level = content[0]`,
        `    hwpx_level = level - 1`,
        `    if hwpx_level not in self.dynamic_style_map:`,
        `        raise ValueError(f"Requested Header Level {level} (HWPX Level {hwpx_level}) not found in header.xml style map.")`,
        `    inlines = content[2]`,
        `    column_break_val = 0`,
        `    if inlines and len(inlines) > 0 and inlines[0].get('t') == 'LineBreak':`,
        `        column_break_val = 1`,
        `        inlines = inlines[1:]`,
        `    style_id = 0`,
        `    if hwpx_level in self.outline_style_ids:`,
        `        style_id = self.outline_style_ids[hwpx_level]`,
        `    else:`,
        `        style_id = hwpx_level`,
        `    para_pr_id = self.normal_para_pr_id`,
        `    char_pr_id = 0`,
        `    if self.header_root is not None:`,
        `        style_node = self.header_root.find(f'.//hh:style[@id="{style_id}"]', self.namespaces)`,
        `        if style_node is not None:`,
        `            para_pr_id = style_node.get('paraPrIDRef', 0)`,
        `            char_pr_id = style_node.get('charPrIDRef', 0)`,
        `    xml = self._create_para_start(style_id=style_id, para_pr_id=para_pr_id, column_break=column_break_val)`,
        `    xml += self._process_inlines(inlines, base_char_pr_id=char_pr_id)`,
        `    xml += '</hp:p>'`,
        `    return xml`,
        `PandocToHwpx._handle_header = _hwp_writer_fix_handle_header`,
        `PandocToHwpx.convert_to_hwpx(r"${escapePath(inputPath)}", r"${escapePath(outputPath)}", r"${escapePath(templatePath)}")`,
        `print("DONE")`
      ].join("\n");
      const result = await this.runPythonScript(pyCode);
      if (!result.includes("DONE")) {
        throw new Error(`\uBCC0\uD658 \uC2E4\uD328: ${result}`);
      }
      if (fs.existsSync(outputPath)) {
        const data = fs.readFileSync(outputPath);
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      } else {
        throw new Error("HWPX \uD30C\uC77C\uC774 \uC0DD\uC131\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      }
    } finally {
      try {
        fs.unlinkSync(inputPath);
      } catch (e) {
      }
      try {
        fs.unlinkSync(outputPath);
      } catch (e) {
      }
    }
  }
  /**
   * 마크다운 → HTML 변환 (pypandoc-hwpx PandocToHtml 사용)
   *
   * 라이브 미리보기에서 HWPX 변환 파이프라인(Pandoc AST)과
   * 최대한 동일한 구조를 사용하기 위해 제공됩니다.
   */
  async convertToHtml(markdown) {
    const fs = require("fs");
    const path2 = require("path");
    const os = require("os");
    const tempDir = fs.mkdtempSync(path2.join(os.tmpdir(), "hwp_writer_html_"));
    const inputPath = path2.join(tempDir, "input.md");
    const outputPath = path2.join(tempDir, "output.html");
    try {
      fs.writeFileSync(inputPath, markdown, "utf-8");
      const escapePath = (p) => p.replace(/\\/g, "\\\\");
      const pyCode = [
        `from pypandoc_hwpx.PandocToHtml import PandocToHtml`,
        `PandocToHtml.convert_to_html(r"${escapePath(inputPath)}", r"${escapePath(outputPath)}")`,
        `print("DONE")`
      ].join("\n");
      const result = await this.runPythonScript(pyCode);
      if (!result.includes("DONE")) {
        throw new Error(`HTML \uBCC0\uD658 \uC2E4\uD328: ${result}`);
      }
      if (!fs.existsSync(outputPath)) {
        throw new Error("HTML \uD30C\uC77C\uC774 \uC0DD\uC131\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      }
      return fs.readFileSync(outputPath, "utf-8");
    } finally {
      try {
        fs.rmSync(tempDir, { recursive: true, force: true });
      } catch (e) {
      }
    }
  }
  /**
   * Python 스크립트 실행 (임시 .py 파일 — Windows 호환)
   */
  runPythonScript(code) {
    return new Promise((resolve, reject) => {
      const { execFile: execFile2 } = require("child_process");
      const fs = require("fs");
      const path2 = require("path");
      const os = require("os");
      const tmpScript = path2.join(os.tmpdir(), `hwp_writer_script_${Date.now()}.py`);
      fs.writeFileSync(tmpScript, code, "utf-8");
      const env = { ...process.env };
      const configuredPandoc = (this.settings.pandocPath || "").trim();
      if (configuredPandoc) {
        env.PYPANDOC_PANDOC = configuredPandoc;
        env.PANDOC_PATH = configuredPandoc;
      }
      execFile2(
        this.settings.pythonPath,
        [tmpScript],
        { timeout: 6e4, windowsHide: true, maxBuffer: 10 * 1024 * 1024, env },
        (error, stdout, stderr) => {
          try {
            fs.unlinkSync(tmpScript);
          } catch (e) {
          }
          if (error) {
            reject(new Error((stderr == null ? void 0 : stderr.trim()) || error.message));
          } else {
            resolve(stdout.trim());
          }
        }
      );
    });
  }
};

// src/main.ts
init_SetupGuideModal();

// src/template/TemplateManager.ts
var import_obsidian6 = require("obsidian");
var TemplateManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.templateDir = ".obsidian/hwp-templates";
  }
  /**
   * 템플릿 디렉토리 확보
   */
  async ensureTemplateDir() {
    const adapter = this.plugin.app.vault.adapter;
    if (!await adapter.exists(this.templateDir)) {
      await adapter.mkdir(this.templateDir);
    }
  }
  /**
   * 저장된 템플릿 목록 반환
   */
  async listTemplates() {
    await this.ensureTemplateDir();
    const adapter = this.plugin.app.vault.adapter;
    const files = await adapter.list(this.templateDir);
    return files.files.filter((f) => f.endsWith(".hwpx"));
  }
  /**
   * 외부 HWPX 파일을 템플릿 디렉토리에 임포트
   */
  async importTemplate(sourcePath, displayName) {
    await this.ensureTemplateDir();
    const fs = require("fs");
    const path2 = require("path");
    const fileName = displayName.endsWith(".hwpx") ? displayName : `${displayName}.hwpx`;
    const destPath = `${this.templateDir}/${fileName}`;
    const adapter = this.plugin.app.vault.adapter;
    const data = fs.readFileSync(sourcePath);
    await adapter.writeBinary(destPath, data);
    new import_obsidian6.Notice(`\uD15C\uD50C\uB9BF \uC784\uD3EC\uD2B8 \uC644\uB8CC: ${fileName}`);
    return destPath;
  }
  /**
   * 템플릿 삭제
   */
  async deleteTemplate(templatePath) {
    const adapter = this.plugin.app.vault.adapter;
    if (await adapter.exists(templatePath)) {
      await adapter.remove(templatePath);
      new import_obsidian6.Notice("\uD15C\uD50C\uB9BF \uC0AD\uC81C \uC644\uB8CC");
    }
  }
  /**
   * 현재 기본 템플릿의 절대 경로 반환
   */
  getDefaultTemplatePath() {
    var _a;
    const setting = this.plugin.settings.defaultTemplatePath;
    if (!setting)
      return null;
    const adapter = this.plugin.app.vault.adapter;
    const basePath = ((_a = adapter.getBasePath) == null ? void 0 : _a.call(adapter)) || "";
    const path2 = require("path");
    return path2.join(basePath, setting);
  }
};
var TemplatePickerModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, onSelect) {
    super(app);
    this.plugin = plugin;
    this.templateManager = new TemplateManager(plugin);
    this.onSelect = onSelect;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("hwp-template-picker");
    contentEl.createEl("h2", { text: "\u{1F4C4} HWPX \uD15C\uD50C\uB9BF \uC120\uD0DD" });
    contentEl.createEl("p", {
      text: "\uBCC0\uD658 \uC2DC \uC0AC\uC6A9\uD560 HWPX \uD15C\uD50C\uB9BF\uC744 \uC120\uD0DD\uD558\uC138\uC694. \uD55C\uAE00\uC5D0\uC11C F6\uC73C\uB85C \uB9CC\uB4E0 \uCEE4\uC2A4\uD140 .hwpx \uD30C\uC77C\uC744 \uC784\uD3EC\uD2B8\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
      cls: "setting-item-description"
    });
    const defaultSection = contentEl.createDiv("hwp-template-section");
    new import_obsidian6.Setting(defaultSection).setName("\uAE30\uBCF8 \uD15C\uD50C\uB9BF (\uB0B4\uC7A5)").setDesc("pypandoc-hwpx \uAE30\uBCF8 \uC2A4\uD0C0\uC77C").addButton(
      (btn) => btn.setButtonText("\uC120\uD0DD").setCta().onClick(async () => {
        this.plugin.settings.defaultTemplatePath = "";
        await this.plugin.saveSettings();
        this.onSelect("");
        new import_obsidian6.Notice("\uAE30\uBCF8 \uD15C\uD50C\uB9BF \uC120\uD0DD\uB428");
        this.close();
      })
    );
    const templates = await this.templateManager.listTemplates();
    if (templates.length > 0) {
      contentEl.createEl("h3", { text: "\uC800\uC7A5\uB41C \uD15C\uD50C\uB9BF" });
      for (const t of templates) {
        const name = t.split("/").pop() || t;
        new import_obsidian6.Setting(contentEl).setName(name).addButton(
          (btn) => btn.setButtonText("\uC120\uD0DD").setCta().onClick(async () => {
            this.plugin.settings.defaultTemplatePath = t;
            await this.plugin.saveSettings();
            this.onSelect(t);
            new import_obsidian6.Notice(`\uD15C\uD50C\uB9BF \uC120\uD0DD: ${name}`);
            this.close();
          })
        ).addButton(
          (btn) => btn.setButtonText("\uC0AD\uC81C").setWarning().onClick(async () => {
            await this.templateManager.deleteTemplate(t);
            this.onOpen();
          })
        );
      }
    }
    contentEl.createEl("h3", { text: "\uC0C8 \uD15C\uD50C\uB9BF \uCD94\uAC00" });
    new import_obsidian6.Setting(contentEl).setName("HWPX \uD30C\uC77C \uC784\uD3EC\uD2B8").setDesc(".hwpx \uD30C\uC77C\uC744 \uC120\uD0DD\uD558\uC5EC \uD15C\uD50C\uB9BF\uC73C\uB85C \uCD94\uAC00\uD569\uB2C8\uB2E4").addButton(
      (btn) => btn.setButtonText("\u{1F4C1} \uD30C\uC77C \uC120\uD0DD").onClick(() => {
        this.openFileDialog();
      })
    );
  }
  openFileDialog() {
    const { remote } = require("electron");
    const dialog = remote == null ? void 0 : remote.dialog;
    if (!dialog) {
      new import_obsidian6.Notice("\uD30C\uC77C \uB300\uD654\uC0C1\uC790\uB97C \uC5F4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
      return;
    }
    dialog.showOpenDialog({
      title: "HWPX \uD15C\uD50C\uB9BF \uC120\uD0DD",
      filters: [{ name: "HWPX Files", extensions: ["hwpx"] }],
      properties: ["openFile"]
    }).then(async (result) => {
      if (!result.canceled && result.filePaths.length > 0) {
        const filePath = result.filePaths[0];
        const path2 = require("path");
        const name = path2.basename(filePath);
        await this.templateManager.importTemplate(filePath, name);
        this.onOpen();
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/export/ExportManager.ts
var import_obsidian7 = require("obsidian");
var ExportManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.preprocessor = new MarkdownPreprocessor();
  }
  // ── HWPX 내보내기 (pypandoc-hwpx) ──
  async exportHwpx(editor, view) {
    var _a, _b, _c;
    const markdown = editor.getValue();
    if (!markdown.trim()) {
      new import_obsidian7.Notice("\uB0B4\uBCF4\uB0BC \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (!this.plugin.pandocBridge) {
      new import_obsidian7.Notice("Python/Pandoc\uC774 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      const { SetupGuideModal: SetupGuideModal2 } = (init_SetupGuideModal(), __toCommonJS(SetupGuideModal_exports));
      new SetupGuideModal2(this.plugin.app, this.plugin).open();
      return;
    }
    try {
      new import_obsidian7.Notice("HWPX \uBCC0\uD658 \uC911...");
      const result = await this.plugin.pandocBridge.convert(markdown, this.plugin.settings);
      if (result) {
        const fileName = ((_a = view.file) == null ? void 0 : _a.basename) || "output";
        const folder = ((_c = (_b = view.file) == null ? void 0 : _b.parent) == null ? void 0 : _c.path) || "";
        const outputPath = folder ? `${folder}/${fileName}.hwpx` : `${fileName}.hwpx`;
        const existing = this.plugin.app.vault.getAbstractFileByPath(outputPath);
        const data = new Uint8Array(result);
        if (existing instanceof import_obsidian7.TFile) {
          await this.plugin.app.vault.modifyBinary(existing, data.buffer);
        } else {
          await this.plugin.app.vault.createBinary(outputPath, data.buffer);
        }
        new import_obsidian7.Notice(`\u2705 HWPX \uB0B4\uBCF4\uB0B4\uAE30 \uC644\uB8CC: ${outputPath}`);
      }
    } catch (e) {
      new import_obsidian7.Notice(`\u274C HWPX \uB0B4\uBCF4\uB0B4\uAE30 \uC2E4\uD328: ${e.message}`);
      console.error("HWPX export error:", e);
    }
  }
  // ── PDF 내보내기 ──
  async exportPdf(editor, view) {
    var _a, _b, _c, _d;
    const markdown = editor.getValue();
    if (!markdown.trim()) {
      new import_obsidian7.Notice("\uB0B4\uBCF4\uB0BC \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      new import_obsidian7.Notice("PDF \uBCC0\uD658 \uC911...");
      const htmlContent = this.generateHwpHtml(markdown);
      const pageLayout = this.resolvePageLayout();
      const fullHtml = this.wrapPdfHtml(htmlContent, ((_a = view.file) == null ? void 0 : _a.basename) || "\uBB38\uC11C", pageLayout);
      const pageSizeMicrons = {
        width: Math.round(pageLayout.width_pt / 72 * 25400),
        height: Math.round(pageLayout.height_pt / 72 * 25400)
      };
      const { remote, BrowserWindow } = require("electron");
      const electronRemote = remote || require("@electron/remote");
      const win = new (electronRemote.BrowserWindow || BrowserWindow)({
        show: false,
        width: 794,
        height: 1123,
        webPreferences: { offscreen: true }
      });
      await win.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(fullHtml)}`);
      await new Promise((r) => setTimeout(r, 500));
      const pdfData = await win.webContents.printToPDF({
        marginsType: 0,
        pageSize: pageSizeMicrons,
        printBackground: true,
        landscape: false
      });
      win.close();
      const fileName = ((_b = view.file) == null ? void 0 : _b.basename) || "output";
      const folder = ((_d = (_c = view.file) == null ? void 0 : _c.parent) == null ? void 0 : _d.path) || "";
      const outputPath = folder ? `${folder}/${fileName}.pdf` : `${fileName}.pdf`;
      const existing = this.plugin.app.vault.getAbstractFileByPath(outputPath);
      if (existing instanceof import_obsidian7.TFile) {
        await this.plugin.app.vault.modifyBinary(existing, pdfData);
      } else {
        await this.plugin.app.vault.createBinary(outputPath, pdfData);
      }
      new import_obsidian7.Notice(`\u2705 PDF \uB0B4\uBCF4\uB0B4\uAE30 \uC644\uB8CC: ${outputPath}`);
    } catch (e) {
      console.error("PDF export error:", e);
      new import_obsidian7.Notice("PDF \uB0B4\uBCF4\uB0B4\uAE30: \uBE0C\uB77C\uC6B0\uC800 \uC778\uC1C4\uB97C \uC0AC\uC6A9\uD569\uB2C8\uB2E4...");
      this.exportPdfFallback(editor, view);
    }
  }
  exportPdfFallback(editor, view) {
    var _a;
    const markdown = editor.getValue();
    const htmlContent = this.generateHwpHtml(markdown);
    const pageLayout = this.resolvePageLayout();
    const fullHtml = this.wrapPdfHtml(htmlContent, ((_a = view.file) == null ? void 0 : _a.basename) || "\uBB38\uC11C", pageLayout);
    this.writeHtmlFile(fullHtml, view, "pdf").then(() => {
      new import_obsidian7.Notice("HTML \uD30C\uC77C\uC774 \uC0DD\uC131\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uBE0C\uB77C\uC6B0\uC800\uC5D0\uC11C \uC5F4\uC5B4 Ctrl+P\uB85C PDF \uC778\uC1C4\uD558\uC138\uC694.");
    });
  }
  // ── HTML 내보내기 ──
  async exportHtml(editor, view) {
    var _a;
    const markdown = editor.getValue();
    if (!markdown.trim()) {
      new import_obsidian7.Notice("\uB0B4\uBCF4\uB0BC \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      new import_obsidian7.Notice("HTML \uBCC0\uD658 \uC911...");
      const htmlContent = this.generateHwpHtml(markdown);
      const pageLayout = this.resolvePageLayout();
      const fullHtml = this.wrapStandaloneHtml(htmlContent, ((_a = view.file) == null ? void 0 : _a.basename) || "\uBB38\uC11C", pageLayout);
      await this.writeHtmlFile(fullHtml, view, "html");
      new import_obsidian7.Notice(`\u2705 HTML \uB0B4\uBCF4\uB0B4\uAE30 \uC644\uB8CC`);
    } catch (e) {
      new import_obsidian7.Notice(`\u274C HTML \uB0B4\uBCF4\uB0B4\uAE30 \uC2E4\uD328: ${e.message}`);
    }
  }
  // ── 공통: 마크다운 → HWP 스타일 HTML ──
  resolvePageLayout() {
    const cached = this.plugin.settings.cachedTemplatePageLayout;
    return {
      width_pt: Number.isFinite(cached == null ? void 0 : cached.width_pt) ? Number(cached == null ? void 0 : cached.width_pt) : DEFAULT_HWPX_PAGE_LAYOUT.width_pt,
      height_pt: Number.isFinite(cached == null ? void 0 : cached.height_pt) ? Number(cached == null ? void 0 : cached.height_pt) : DEFAULT_HWPX_PAGE_LAYOUT.height_pt,
      marginLeft_pt: Number.isFinite(cached == null ? void 0 : cached.marginLeft_pt) ? Number(cached == null ? void 0 : cached.marginLeft_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginLeft_pt,
      marginRight_pt: Number.isFinite(cached == null ? void 0 : cached.marginRight_pt) ? Number(cached == null ? void 0 : cached.marginRight_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginRight_pt,
      marginTop_pt: Number.isFinite(cached == null ? void 0 : cached.marginTop_pt) ? Number(cached == null ? void 0 : cached.marginTop_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginTop_pt,
      marginBottom_pt: Number.isFinite(cached == null ? void 0 : cached.marginBottom_pt) ? Number(cached == null ? void 0 : cached.marginBottom_pt) : DEFAULT_HWPX_PAGE_LAYOUT.marginBottom_pt
    };
  }
  generateHwpHtml(markdown) {
    const blocks = this.preprocessor.preprocess(markdown);
    const cached = this.plugin.settings.cachedTemplateStyles;
    const styles = cached && Object.keys(cached).length > 0 ? cached : DEFAULT_HWPX_STYLES;
    const normalStyle = styles["Normal"] || DEFAULT_HWPX_STYLES["Normal"];
    const htmlLines = [];
    for (const block of blocks) {
      if (block.type === "empty") {
        htmlLines.push(`<div class="hwp-line" style="${this.styleToCss(normalStyle)}">&nbsp;</div>`);
        continue;
      }
      if (block.type === "hr") {
        htmlLines.push('<hr style="border:none;border-top:1px solid #999;margin:12px 0;">');
        continue;
      }
      if (block.type === "table") {
        htmlLines.push(`<div style="font-size:${normalStyle.fontSize_pt}pt;font-family:'${normalStyle.fontFamily}',serif;">${block.html}</div>`);
        continue;
      }
      if (block.type === "codeblock") {
        htmlLines.push(`<div style="margin:8px 0;font-size:${Math.max(normalStyle.fontSize_pt - 1, 8)}pt;">${block.html}</div>`);
        continue;
      }
      const hwpxStyleName = this.mapToHwpxStyle(block.type);
      const style = styles[hwpxStyleName] || normalStyle;
      let css = this.styleToCss(style, block.indent);
      if (block.type === "quote") {
        css += ";border-left:2px solid #4a86c8;padding-left:9pt;color:#555;";
      }
      if (block.type === "list") {
        const bulletPt = 12;
        css += `;text-indent:-${bulletPt}pt`;
        css += `;padding-left:${bulletPt}pt`;
      }
      htmlLines.push(`<div class="hwp-line" style="${css}">${block.html}</div>`);
    }
    return htmlLines.join("\n");
  }
  mapToHwpxStyle(type) {
    switch (type) {
      case "h1":
        return "Heading 1";
      case "h2":
        return "Heading 2";
      case "h3":
        return "Heading 3";
      case "h4":
        return "Heading 4";
      case "h5":
        return "Heading 5";
      case "h6":
        return "Heading 6";
      case "h7":
        return "Heading 7";
      case "h8":
        return "Heading 8";
      case "h9":
        return "Heading 9";
      case "quote":
        return "Normal";
      case "list":
        return "Normal";
      case "body":
        return "Normal";
      default:
        return "Normal";
    }
  }
  styleToCss(style, indent = 0) {
    const parts = [];
    if (style.fontSize_pt)
      parts.push(`font-size:${style.fontSize_pt}pt`);
    if (style.fontFamily)
      parts.push(`font-family:'${style.fontFamily}','\uB9D1\uC740 \uACE0\uB515','Malgun Gothic',serif`);
    if (style.bold)
      parts.push("font-weight:bold");
    if (style.italic)
      parts.push("font-style:italic");
    const textDecorations = [];
    if (style.underline)
      textDecorations.push("underline");
    if (style.strikeout)
      textDecorations.push("line-through");
    if (textDecorations.length > 0) {
      parts.push(`text-decoration:${textDecorations.join(" ")}`);
    }
    if (style.textColor && style.textColor !== "#000000" && style.textColor !== "none") {
      parts.push(`color:${style.textColor}`);
    }
    if (style.charSpacing_pct && style.charSpacing_pct !== 0) {
      parts.push(`letter-spacing:${(style.charSpacing_pct / 100).toFixed(2)}em`);
    }
    if (style.charWidth_pct && style.charWidth_pct !== 100) {
      parts.push(`font-stretch:${style.charWidth_pct}%`);
    }
    if (style.align)
      parts.push(`text-align:${style.align}`);
    if (style.lineSpacing_pt != null && style.lineSpacing_pt > 0) {
      parts.push(`line-height:${style.lineSpacing_pt}pt`);
    } else if (style.lineSpacing_pct && style.lineSpacing_pct > 0) {
      parts.push(`line-height:${(style.lineSpacing_pct / 100).toFixed(2)}`);
    }
    const ml = (style.marginLeft_pt || 0) + (indent > 0 ? indent * 20 : 0);
    if (ml > 0)
      parts.push(`margin-left:${ml}pt`);
    if (style.marginRight_pt && style.marginRight_pt > 0) {
      parts.push(`margin-right:${style.marginRight_pt}pt`);
    }
    if (style.indent_pt && style.indent_pt > 0 && indent === 0) {
      parts.push(`text-indent:${style.indent_pt}pt`);
    }
    if (style.spacingBefore_pt && style.spacingBefore_pt > 0) {
      parts.push(`margin-top:${style.spacingBefore_pt}pt`);
    }
    if (style.spacingAfter_pt && style.spacingAfter_pt > 0) {
      parts.push(`margin-bottom:${style.spacingAfter_pt}pt`);
    }
    return parts.join(";");
  }
  // ── HTML 래퍼 ──
  wrapPdfHtml(body, title, page) {
    return `<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>${this.escHtml(title)}</title>
<style>
@page { size: ${page.width_pt}pt ${page.height_pt}pt; margin: 0; }
body { margin: 0; padding: 0; }
.hwp-paper {
  width: ${page.width_pt}pt;
  min-height: ${page.height_pt}pt;
  padding: ${page.marginTop_pt}pt ${page.marginRight_pt}pt ${page.marginBottom_pt}pt ${page.marginLeft_pt}pt;
  box-sizing: border-box;
  font-family: '\uD568\uCD08\uB86C\uBC14\uD0D5', 'Batang', serif;
  color: #1a1a1a;
  word-break: keep-all;
}
.hwp-line { margin: 0; padding: 1px 0; }
a { color: #1a73e8; text-decoration: underline; }
table { border-collapse: collapse; width: 100%; }
th, td { border: 1px solid #ccc; padding: 6px 10px; }
th { background: #f0f4f8; font-weight: bold; }
pre { background: #f8f9fa; padding: 12px; border-radius: 4px; overflow-x: auto; }
code { font-family: 'Consolas', 'D2Coding', monospace; }
</style>
</head>
<body><div class="hwp-paper">${body}</div></body>
</html>`;
  }
  wrapStandaloneHtml(body, title, page) {
    return `<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${this.escHtml(title)}</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #e8e8e8; display: flex; justify-content: center; padding: 40px 20px; }
.hwp-paper {
  background: #fff;
  width: ${page.width_pt}pt;
  min-height: ${page.height_pt}pt;
  padding: ${page.marginTop_pt}pt ${page.marginRight_pt}pt ${page.marginBottom_pt}pt ${page.marginLeft_pt}pt;
  box-sizing: border-box;
  box-shadow: 0 2px 10px rgba(0,0,0,0.15);
  font-family: '\uD568\uCD08\uB86C\uBC14\uD0D5', 'Batang', 'Times New Roman', serif;
  font-size: 12pt; line-height: 1.6; color: #1a1a1a;
  word-break: keep-all; overflow-wrap: break-word;
}
.hwp-line { margin: 0; padding: 1px 0; }
a { color: #1a73e8; text-decoration: underline; }
table { border-collapse: collapse; width: 100%; margin: 8px 0; }
th, td { border: 1px solid #ccc; padding: 6px 10px; }
th { background: #f0f4f8; font-weight: bold; }
pre { background: #f8f9fa; padding: 12px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; }
code { font-family: 'Consolas', 'D2Coding', monospace; }
mark { background: #fef08a; padding: 0 2px; }
@media print {
  body { background: none; padding: 0; }
  .hwp-paper { box-shadow: none; }
}
</style>
</head>
<body><div class="hwp-paper">${body}</div></body>
</html>`;
  }
  async writeHtmlFile(html, view, suffix) {
    var _a, _b, _c;
    const fileName = ((_a = view.file) == null ? void 0 : _a.basename) || "output";
    const folder = ((_c = (_b = view.file) == null ? void 0 : _b.parent) == null ? void 0 : _c.path) || "";
    const outputPath = folder ? `${folder}/${fileName}_${suffix}.html` : `${fileName}_${suffix}.html`;
    const existing = this.plugin.app.vault.getAbstractFileByPath(outputPath);
    if (existing instanceof import_obsidian7.TFile) {
      await this.plugin.app.vault.modify(existing, html);
    } else {
      await this.plugin.app.vault.create(outputPath, html);
    }
  }
  escHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
};

// src/font/FontLoader.ts
var registeredFonts = [];
var LOCAL_FONT_STYLE_ID = "hwp-writer-local-fonts";
var HWPX_FONT_MAP = {
  "HY\uD5E4\uB4DC\uB77C\uC778M": {
    files: ["H2HDRM.TTF"],
    localNames: ["HY\uD5E4\uB4DC\uB77C\uC778M", "HYHeadLine-Medium", "HY HeadLine M", "HYHeadLineM"]
  },
  "HY\uC2E0\uBA85\uC870": {
    files: ["H2MJSM.TTF"],
    localNames: ["HY\uC2E0\uBA85\uC870", "HYSinMyeongJo-Medium", "HY SinMyeongjo"]
  },
  "HY\uACAC\uBA85\uC870": {
    files: ["H2MJRE.TTF"],
    localNames: ["HY\uACAC\uBA85\uC870", "HYMyeongJo-Extra"]
  },
  "HY\uC911\uACE0\uB515": {
    files: ["H2GTRM.TTF"],
    localNames: ["HY\uC911\uACE0\uB515", "HYJungGothic-Medium", "HY JungGothic"]
  },
  "HY\uACAC\uACE0\uB515": {
    files: ["H2GTRE.TTF"],
    localNames: ["HY\uACAC\uACE0\uB515", "HYGothic-Extra", "HYGeonGothic-Bold"]
  },
  "HY\uADF8\uB798\uD53DM": {
    files: ["H2GPRM.TTF"],
    localNames: ["HY\uADF8\uB798\uD53DM", "HYGraphic-Medium", "HYGraphic", "HY\uADF8\uB798\uD53D"]
  },
  "HY\uAD81\uC11CB": {
    files: ["H2GSRB.TTF"],
    localNames: ["HY\uAD81\uC11CB", "HYGungSo-Bold", "HY GungSo B"]
  },
  // 휴먼명조 → 실제로는 HY신명조 계열
  "\uD734\uBA3C\uBA85\uC870": {
    files: ["H2MJSM.TTF"],
    localNames: ["\uD734\uBA3C\uBA85\uC870", "HY\uC2E0\uBA85\uC870", "HYSinMyeongJo-Medium", "HY Myeongjo", "HYMyeongJo"]
  },
  "\uD734\uBA3C\uC61B\uCCB4": {
    files: ["HMFMOLD.TTF"],
    localNames: ["\uD734\uBA3C\uC61B\uCCB4", "Yet R"]
  },
  "\uD734\uBA3C\uD3B8\uC9C0\uCCB4": {
    files: ["HMFMPYUN.TTF"],
    localNames: ["\uD734\uBA3C\uD3B8\uC9C0\uCCB4", "Pyunji R"]
  },
  "\uD734\uBA3C\uC544\uBBF8\uCCB4": {
    files: ["HMKMAMI.TTF"],
    localNames: ["\uD734\uBA3C\uC544\uBBF8\uCCB4", "Ami R"]
  },
  "\uD568\uCD08\uB86C\uBC14\uD0D5": {
    files: ["HANBatang.ttf"],
    localNames: ["\uD568\uCD08\uB86C\uBC14\uD0D5", "HCR Batang"]
  },
  "\uD568\uCD08\uB86C\uB3CB\uC6C0": {
    files: ["HANDotum.ttf"],
    localNames: ["\uD568\uCD08\uB86C\uB3CB\uC6C0", "HCR Dotum"]
  },
  "\uB9D1\uC740 \uACE0\uB515": {
    files: ["malgun.ttf"],
    localNames: ["\uB9D1\uC740 \uACE0\uB515", "Malgun Gothic"]
  },
  "\uBC14\uD0D5": {
    files: ["batang.ttc"],
    localNames: ["\uBC14\uD0D5", "Batang"]
  },
  "\uB3CB\uC6C0": {
    files: ["gulim.ttc"],
    localNames: ["\uB3CB\uC6C0", "Dotum"]
  },
  "\uAD74\uB9BC": {
    files: ["gulim.ttc"],
    localNames: ["\uAD74\uB9BC", "Gulim"]
  },
  "\uB098\uB214\uACE0\uB515": {
    files: ["NanumGothic.otf", "NanumGothic_0.ttf"],
    localNames: ["\uB098\uB214\uACE0\uB515", "NanumGothic"]
  },
  "\uB098\uB214\uBA85\uC870": {
    files: ["NanumMyeongjo.otf", "NanumMyeongjo.ttf"],
    localNames: ["\uB098\uB214\uBA85\uC870", "NanumMyeongjo"]
  },
  "\uAD81\uC11C": {
    files: ["gungsuh.ttf"],
    localNames: ["\uAD81\uC11C", "Gungsuh"]
  },
  "\uD55C\uCEF4\uBC14\uD0D5": {
    files: [],
    localNames: ["\uD55C\uCEF4\uBC14\uD0D5", "HancomBatang", "Hancom Batang"]
  },
  "\uD55C\uCEF4\uB3CB\uC6C0": {
    files: [],
    localNames: ["\uD55C\uCEF4\uB3CB\uC6C0", "HancomDotum", "Hancom Dotum"]
  }
};
function injectLocalFontFaces() {
  const existing = document.getElementById(LOCAL_FONT_STYLE_ID);
  if (existing) {
    existing.remove();
  }
  const rules = [];
  for (const [fontName, mapping] of Object.entries(HWPX_FONT_MAP)) {
    const localSources = mapping.localNames.map((n) => `local("${n}")`).join(", ");
    rules.push(
      `@font-face {
  font-family: "${fontName}";
  src: ${localSources};
  font-display: swap;
}`
    );
  }
  const styleEl = document.createElement("style");
  styleEl.id = LOCAL_FONT_STYLE_ID;
  styleEl.textContent = rules.join("\n\n");
  document.head.appendChild(styleEl);
  console.log(
    `HWP Writer FontLoader: @font-face local() \uADDC\uCE59 ${rules.length}\uAC1C \uC8FC\uC785 \uC644\uB8CC`
  );
  return rules.length;
}
async function loadFontsForTemplate(fontDirPath, styles) {
  for (const font of registeredFonts) {
    try {
      document.fonts.delete(font);
    } catch (_) {
    }
  }
  registeredFonts = [];
  const neededFonts = /* @__PURE__ */ new Set();
  for (const style of Object.values(styles)) {
    if (style.fontFamily) {
      neededFonts.add(style.fontFamily);
    }
  }
  if (neededFonts.size === 0) {
    console.log("HWP Writer FontLoader: \uD15C\uD50C\uB9BF\uC5D0 \uD3F0\uD2B8 \uC815\uBCF4 \uC5C6\uC74C");
    return 0;
  }
  console.log("HWP Writer FontLoader: \uD544\uC694\uD55C \uD3F0\uD2B8 \u2192", Array.from(neededFonts));
  let loadedCount = 0;
  const fontsToLoadFromDisk = /* @__PURE__ */ new Set();
  for (const fontName of neededFonts) {
    const mapping = HWPX_FONT_MAP[fontName];
    if (!mapping) {
      fontsToLoadFromDisk.add(fontName);
      continue;
    }
    let isNativeAvailable = false;
    for (const localName of mapping.localNames) {
      if (document.fonts.check(`12px "${localName}"`)) {
        isNativeAvailable = true;
        break;
      }
    }
    if (isNativeAvailable) {
      console.log(`HWP Writer FontLoader: "${fontName}" \uC2DC\uC2A4\uD15C \uD3F0\uD2B8 \uC778\uC2DD\uB428 (\uD30C\uC77C \uB85C\uB529 \uC0DD\uB7B5)`);
      loadedCount++;
    } else {
      fontsToLoadFromDisk.add(fontName);
    }
  }
  injectLocalFontFaces();
  await document.fonts.ready;
  for (const fontName of fontsToLoadFromDisk) {
    const mapping = HWPX_FONT_MAP[fontName];
    if (!mapping) {
      console.warn(`HWP Writer FontLoader: "${fontName}" \uB9E4\uD551 \uC5C6\uC74C, \uAC74\uB108\uB700`);
      continue;
    }
    console.log(
      `HWP Writer FontLoader: "${fontName}" \uD30C\uC77C \uC77D\uAE30 \uC2DC\uB3C4 (\uC548\uC815\uC801 \uB85C\uB529)`
    );
    let loaded = false;
    const fs = require("fs");
    const path2 = require("path");
    for (const fileName of mapping.files) {
      const filePath = path2.join(fontDirPath, fileName);
      try {
        if (!fs.existsSync(filePath))
          continue;
        const buffer = fs.readFileSync(filePath);
        const fontData = new Uint8Array(buffer);
        const fontFace = new FontFace(fontName, fontData, {
          style: "normal",
          weight: "400",
          display: "swap"
        });
        await fontFace.load();
        document.fonts.add(fontFace);
        registeredFonts.push(fontFace);
        await document.fonts.ready;
        const sizeKB = (buffer.length / 1024).toFixed(0);
        const verifyCheck = document.fonts.check(`12px "${fontName}"`);
        console.log(
          `HWP Writer FontLoader: \u2713 "${fontName}" \uD30C\uC77C \uB85C\uB4DC \uC644\uB8CC (${fileName}, ${sizeKB}KB, status: ${fontFace.status}, check: ${verifyCheck})`
        );
        loaded = true;
        loadedCount++;
        break;
      } catch (e) {
        console.warn(
          `HWP Writer FontLoader: "${fontName}" ${fileName} \uD30C\uC77C \uB85C\uB4DC \uC2E4\uD328:`,
          e
        );
      }
    }
    if (!loaded) {
      console.warn(
        `HWP Writer FontLoader: \u2717 "${fontName}" \uB4F1\uB85D \uC2E4\uD328 (local + \uD30C\uC77C \uBAA8\uB450 \uC2E4\uD328)`
      );
    }
  }
  console.log(
    `HWP Writer FontLoader: \uCD1D ${loadedCount}/${neededFonts.size}\uAC1C \uD3F0\uD2B8 \uC0AC\uC6A9 \uAC00\uB2A5`
  );
  const fontList = [];
  document.fonts.forEach((f) => {
    if (f.family.includes("HY") || f.family.includes("\uD568\uCD08\uB86C") || f.family.includes("\uD734\uBA3C") || f.family.includes("\uBA85\uC870") || f.family.includes("\uBC14\uD0D5") || f.family.includes("\uB098\uB214")) {
      fontList.push(`${f.family} (${f.status})`);
    }
  });
  if (fontList.length > 0) {
    console.log("HWP Writer FontLoader: \uB4F1\uB85D\uB41C \uCEE4\uC2A4\uD140 \uD3F0\uD2B8:", fontList);
  }
  return loadedCount;
}
function unloadFontStyles() {
  for (const font of registeredFonts) {
    try {
      document.fonts.delete(font);
    } catch (_) {
    }
  }
  registeredFonts = [];
  const styleEl = document.getElementById(LOCAL_FONT_STYLE_ID);
  if (styleEl) {
    styleEl.remove();
  }
}

// src/main.ts
var HwpWriterPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.pandocBridge = null;
    this.templateManager = null;
    this.exportManager = null;
    this.toolbarManager = null;
  }
  async onload() {
    await this.loadSettings();
    this.templateManager = new TemplateManager(this);
    this.exportManager = new ExportManager(this);
    this.toolbarManager = new ToolbarManager(this);
    this.registerView(PREVIEW_VIEW_TYPE, (leaf) => new PreviewView(leaf, this));
    registerCommands(this);
    this.addSettingTab(new HwpWriterSettingTab(this.app, this));
    this.addRibbonIcon("file-text", "HWP \uD234\uBC14 \uC5F4\uAE30/\uC228\uAE30\uAE30", () => {
      var _a;
      (_a = this.toolbarManager) == null ? void 0 : _a.toggle();
    });
    this.addCommand({
      id: "toggle-toolbar",
      name: "HWP \uD234\uBC14 \uC5F4\uAE30/\uC228\uAE30\uAE30",
      callback: () => {
        var _a;
        return (_a = this.toolbarManager) == null ? void 0 : _a.toggle();
      }
    });
    this.addCommand({
      id: "toggle-preview",
      name: "HWP \uBBF8\uB9AC\uBCF4\uAE30 \uC5F4\uAE30/\uB2EB\uAE30",
      callback: () => this.activatePreview()
    });
    this.addCommand({
      id: "show-setup-guide",
      name: "Python/Pandoc \uC124\uCE58 \uAC00\uC774\uB4DC",
      callback: () => new SetupGuideModal(this.app, this).open()
    });
    this.addCommand({
      id: "export-hwpx",
      name: "HWPX\uB85C \uB0B4\uBCF4\uB0B4\uAE30",
      editorCallback: (editor, view) => {
        var _a;
        (_a = this.exportManager) == null ? void 0 : _a.exportHwpx(editor, view);
      }
    });
    this.addCommand({
      id: "export-pdf",
      name: "PDF\uB85C \uB0B4\uBCF4\uB0B4\uAE30",
      editorCallback: (editor, view) => {
        var _a;
        (_a = this.exportManager) == null ? void 0 : _a.exportPdf(editor, view);
      }
    });
    this.addCommand({
      id: "export-html",
      name: "HTML\uB85C \uB0B4\uBCF4\uB0B4\uAE30",
      editorCallback: (editor, view) => {
        var _a;
        (_a = this.exportManager) == null ? void 0 : _a.exportHtml(editor, view);
      }
    });
    this.addCommand({
      id: "select-template",
      name: "HWPX \uD15C\uD50C\uB9BF \uC120\uD0DD",
      callback: () => {
        new TemplatePickerModal(this.app, this, async (path2) => {
          this.settings.defaultTemplatePath = path2;
          await this.saveSettings();
          await this.refreshTemplateStyles();
          new import_obsidian8.Notice(`\uD15C\uD50C\uB9BF \uC801\uC6A9: ${path2 || "\uAE30\uBCF8 (blank.hwpx)"}`);
        }).open();
      }
    });
    this.app.workspace.onLayoutReady(() => {
      this.initializePlugin();
    });
    console.log("HWP Writer plugin loaded");
  }
  async onunload() {
    var _a;
    (_a = this.toolbarManager) == null ? void 0 : _a.destroy();
    unloadFontStyles();
    if (this.pandocBridge) {
      await this.pandocBridge.stopServer();
    }
    console.log("HWP Writer plugin unloaded");
  }
  async initializePlugin() {
    var _a, _b;
    if (this.settings.isFirstRun) {
      new SetupGuideModal(this.app, this).open();
      this.settings.isFirstRun = false;
      await this.saveSettings();
    }
    await ((_a = this.templateManager) == null ? void 0 : _a.ensureTemplateDir());
    const pluginDir = this.getPluginDir();
    this.pandocBridge = new PandocBridge(this.settings, pluginDir, this.getVaultBasePath());
    const healthy = await this.pandocBridge.checkHealth();
    if (healthy) {
      console.log("HWP Writer: pypandoc-hwpx \uC0AC\uC6A9 \uAC00\uB2A5 \u2713");
    } else {
      console.log("HWP Writer: pypandoc-hwpx \uBBF8\uC124\uCE58 \u2014 HWPX \uB0B4\uBCF4\uB0B4\uAE30 \uC2DC \uC548\uB0B4 \uD45C\uC2DC");
    }
    await this.refreshTemplateStyles();
    try {
      const styles = this.settings.cachedTemplateStyles || DEFAULT_HWPX_STYLES;
      const fontDir = this.settings.fontDirectoryPath || this.getDefaultFontDirectory();
      const fontCount = await loadFontsForTemplate(fontDir, styles);
      console.log(`HWP Writer initializePlugin: \uD3F0\uD2B8 ${fontCount}\uAC1C \uB4F1\uB85D \uC644\uB8CC`);
      const fontStyleEl = document.getElementById("hwp-writer-font-faces");
      console.log(
        "HWP Writer: @font-face style element \uC874\uC7AC?",
        !!fontStyleEl,
        fontStyleEl ? `(${(_b = fontStyleEl.textContent) == null ? void 0 : _b.length}\uC790)` : ""
      );
    } catch (fontErr) {
      console.error("HWP Writer: \uD3F0\uD2B8 \uB85C\uB4DC \uC2E4\uD328", fontErr);
    }
  }
  /**
   * 현재 선택된 HWPX 템플릿에서 스타일을 추출하여 캐시
   * 템플릿 선택 시 즉시 호출되어 미리보기를 갱신합니다.
   */
  async refreshTemplateStyles() {
    var _a, _b;
    try {
      if (!this.pandocBridge) {
        console.warn("HWP Writer: pandocBridge \uBBF8\uCD08\uAE30\uD654, \uC2A4\uD0C0\uC77C \uCD94\uCD9C \uAC74\uB108\uB700");
        return;
      }
      const templatePath = this.pandocBridge.getActiveTemplatePath();
      console.log("HWP Writer: \uC2A4\uD0C0\uC77C \uCD94\uCD9C \uC2DC\uC791", {
        selectedTemplate: this.settings.defaultTemplatePath,
        resolvedPath: templatePath
      });
      const extracted = await extractHwpxTemplateData(
        templatePath,
        this.settings.pythonPath
      );
      const styles = extracted.styles;
      this.settings.cachedTemplateStyles = styles;
      this.settings.cachedTemplatePageLayout = extracted.page;
      await this.saveSettings();
      const fontDir = this.settings.fontDirectoryPath || this.getDefaultFontDirectory();
      const fontCount = await loadFontsForTemplate(fontDir, styles);
      console.log(`HWP Writer: ${fontCount}\uAC1C \uD15C\uD50C\uB9BF \uD3F0\uD2B8 \uB85C\uB4DC \uC644\uB8CC`);
      this.refreshAllPreviews();
      const normal = styles["Normal"];
      console.log("HWP Writer: \uD15C\uD50C\uB9BF \uC2A4\uD0C0\uC77C \uB85C\uB4DC \uC644\uB8CC", {
        styleCount: Object.keys(styles).length,
        styleNames: Object.keys(styles),
        normalFont: normal == null ? void 0 : normal.fontFamily,
        normalSize: normal == null ? void 0 : normal.fontSize_pt,
        h1Font: (_a = styles["Heading 1"]) == null ? void 0 : _a.fontFamily,
        h1Align: (_b = styles["Heading 1"]) == null ? void 0 : _b.align,
        page: extracted.page
      });
    } catch (e) {
      console.warn("HWP Writer: \uD15C\uD50C\uB9BF \uC2A4\uD0C0\uC77C \uCD94\uCD9C \uC2E4\uD328 (\uAE30\uBCF8 \uC2A4\uD0C0\uC77C \uC0AC\uC6A9)", e);
      this.settings.cachedTemplateStyles = DEFAULT_HWPX_STYLES;
      this.settings.cachedTemplatePageLayout = DEFAULT_HWPX_PAGE_LAYOUT;
      await this.saveSettings();
      const fontDir = this.settings.fontDirectoryPath || this.getDefaultFontDirectory();
      await loadFontsForTemplate(fontDir, DEFAULT_HWPX_STYLES);
      this.refreshAllPreviews();
    }
  }
  /**
   * 플러그인 디렉토리 절대 경로
   */
  getPluginDir() {
    const path2 = require("path");
    const vaultPath = this.getVaultBasePath();
    const configDir = this.app.vault.configDir;
    return path2.join(vaultPath, configDir, "plugins", this.manifest.id);
  }
  getVaultBasePath() {
    var _a;
    const adapter = this.app.vault.adapter;
    return adapter.basePath || ((_a = adapter.getBasePath) == null ? void 0 : _a.call(adapter)) || "";
  }
  getDefaultFontDirectory() {
    if (process.platform === "win32")
      return "C:\\Windows\\Fonts";
    if (process.platform === "darwin")
      return "/System/Library/Fonts";
    return "/usr/share/fonts";
  }
  /**
   * 미리보기 열기/닫기 토글
   */
  async activatePreview() {
    const existing = this.app.workspace.getLeavesOfType(PREVIEW_VIEW_TYPE);
    if (existing.length > 0) {
      existing.forEach((leaf2) => leaf2.detach());
      return;
    }
    const leaf = this.app.workspace.getLeaf("split", "vertical");
    await leaf.setViewState({
      type: PREVIEW_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(leaf);
  }
  /**
   * 모든 열린 미리보기 패널을 새로고침
   */
  refreshAllPreviews() {
    var _a;
    const leaves = this.app.workspace.getLeavesOfType(PREVIEW_VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      (_a = view == null ? void 0 : view.forceRefresh) == null ? void 0 : _a.call(view);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
